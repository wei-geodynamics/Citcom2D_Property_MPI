Advection_diffusion.c:    E->advection.temp_iterations = 2; /* petrov-galerkin iterations: minimum value. */
Advection_diffusion.c:    E->advection.total_timesteps = 1; 
Advection_diffusion.c:    E->advection.sub_iterations = 1;
Advection_diffusion.c:    E->advection.last_sub_iterations = 1;
Advection_diffusion.c:    E->advection.gamma = 0.5;
Advection_diffusion.c:    E->advection.dt_reduced = 1.0;         
Advection_diffusion.c:    E->monitor.T_maxvaried = 1e05;
Advection_diffusion.c:    input_boolean("ADV",&(E->advection.ADVECTION),"on");
Advection_diffusion.c:    E->advection.ADVECTION=1;
Advection_diffusion.c:    input_int("visc_heating",&(E->control.visc_heating),"1");
Advection_diffusion.c:    input_int("adi_heating",&(E->control.adi_heating),"1");
Advection_diffusion.c:    input_int("latent_heating",&(E->control.latent_heating),"1");
Advection_diffusion.c:    input_int("minstep",&(E->advection.min_timesteps),"1");
Advection_diffusion.c:    input_int("maxstep",&(E->advection.max_timesteps),"1000");
Advection_diffusion.c:    input_int("maxtotstep",&(E->advection.max_total_timesteps),"1000000");
Advection_diffusion.c:    input_float("finetunedt",&(E->advection.fine_tune_dt),"0.9");
Advection_diffusion.c:    input_float("fixed_timestep",&(E->advection.fixed_timestep),"0.0");
Advection_diffusion.c:    input_int("adv_sub_iterations",&(E->advection.temp_iterations),"2,2,nomax");
Advection_diffusion.c:    input_float("maxadvtime",&(E->advection.max_dimensionless_time),"10.0");
Advection_diffusion.c:    input_float("sub_tolerance",&(E->advection.vel_substep_aggression),"0.005");  
Advection_diffusion.c:    input_int("maxsub",&(E->advection.max_substeps),"25");
Advection_diffusion.c:    input_float("liddefvel",&(E->advection.lid_defining_velocity),"0.01");
Advection_diffusion.c:    input_float("sublayerfrac",&(E->advection.sub_layer_sample_level),"0.5");            
Advection_diffusion.c:    input_int("markers_per_ele",&(E->advection.markers_per_ele),"0");
Advection_diffusion.c:  E->Tdot= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:  for(i=1;i<=E->mesh.nno;i++) 
Advection_diffusion.c:    E->Tdot[i]=0.0;
Advection_diffusion.c:  if (E->control.composition)   {
Advection_diffusion.c:    E->Cdot= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:    for(i=1;i<=E->mesh.nno;i++)
Advection_diffusion.c:      E->Cdot[i]=0.0;
Advection_diffusion.c:    if (!(strcmp(E->control.comp_adv_method,"field")==0)) {
Advection_diffusion.c:      E->advection.markers = E->advection.markers_per_ele*E->mesh.nel;
Advection_diffusion.c:      for(i=1;i<=E->mesh.nsd;i++)   {
Advection_diffusion.c:        E->VO[i] = (float *) malloc ((E->advection.markers+1)*sizeof(float));
Advection_diffusion.c:        E->XMC[i] = (float *) malloc ((E->advection.markers+1)*sizeof(float));
Advection_diffusion.c:        E->XMCpred[i] = (float *) malloc ((E->advection.markers+1)*sizeof(float));
Advection_diffusion.c:      E->C12 = (int *) malloc ((E->advection.markers+1)*sizeof(int));
Advection_diffusion.c:      E->CElement = (int *) malloc ((E->advection.markers+1)*sizeof(int));
Advection_diffusion.c:    if(E->control.phasevisc_C) {
Advection_diffusion.c:      E->Cphase_dot = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:      for(i=1;i<=E->mesh.nno;i++)
Advection_diffusion.c:        E->Cphasedot[i]=0.0;
Advection_diffusion.c:      if (!(strcmp(E->control.comp_adv_method,"field")==0)) {
Advection_diffusion.c:        E->Cphase = (float *) malloc ((E->advection.markers+1)*sizeof(float));
Advection_diffusion.c:      DTdot= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:      E->advection.timesteps++;
Advection_diffusion.c:      E->advection.total_timesteps++;
Advection_diffusion.c:         Runge_Kutta(E,E->XMC,E->XMCpred,E->C,E->V,E->VO);
Advection_diffusion.c:       Euler(E,E->XMC,E->XMCpred,E->C,E->V,E->VO);
Advection_diffusion.c:       if (E->control.Ra_temp>0)  {
Advection_diffusion.c:         predictor(E,E->T,E->Tdot,1);
Advection_diffusion.c:         for(psc_pass=0;psc_pass<E->advection.temp_iterations;psc_pass++)   {
Advection_diffusion.c:             pg_solver(E,E->T,E->Tdot,DTdot,E->V,1.0,E->TB,E->node);
Advection_diffusion.c:             corrector(E,E->T,E->Tdot,DTdot,1);
Advection_diffusion.c:         temperatures_conform_bcs(E,E->T);
Advection_diffusion.c:    if( E->advection.timesteps < E->advection.max_timesteps)
Advection_diffusion.c:        E->control.keep_going = 1;
Advection_diffusion.c:        E->control.keep_going = 0;
Advection_diffusion.c:    DTdot= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:    T1= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:    Tdot1= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:	  E->advection.timesteps=0;
Advection_diffusion.c:    E->advection.timesteps++;
Advection_diffusion.c:   if (E->control.composition)         {
Advection_diffusion.c:	     predictor(E,E->C,E->Cdot,0);
Advection_diffusion.c:	     for(psc_pass=0;psc_pass<E->advection.temp_iterations;psc_pass++) {
Advection_diffusion.c:	 	   pg_solver(E,E->C,E->Cdot,DTdot,E->V,E->control.comp_diff,E->CB,E->node);
Advection_diffusion.c:		   corrector(E,E->C,E->Cdot,DTdot,0);
Advection_diffusion.c:       predictor(E,E->T,E->Tdot,1);
Advection_diffusion.c:       for(psc_pass=0;psc_pass<E->advection.temp_iterations;psc_pass++)   {
Advection_diffusion.c:         pg_solver(E,E->T,E->Tdot,DTdot,E->V,1.0,E->TB,E->node);
Advection_diffusion.c:         corrector(E,E->T,E->Tdot,DTdot,1);
Advection_diffusion.c:    E->advection.total_timesteps++;
Advection_diffusion.c:    temperatures_conform_bcs(E,E->T); 
Advection_diffusion.c:    if( E->advection.timesteps < E->advection.max_timesteps)
Advection_diffusion.c:        E->control.keep_going = 1;
Advection_diffusion.c: 	    E->control.keep_going = 0;
Advection_diffusion.c:   multiplier = (1.0-E->advection.gamma) * E->advection.timestep;
Advection_diffusion.c:    for(node=1;node<=E->mesh.nno;node++)  {
Advection_diffusion.c:	if(!(E->node[node] & (OFFSIDE | TBX | TBZ | TBY))) 
Advection_diffusion.c:    for(node=1;node<=E->mesh.nno;node++)  {
Advection_diffusion.c:	if(!(E->node[node] & OFFSIDE )) 
Advection_diffusion.c:   multiplier = E->advection.gamma * E->advection.timestep;
Advection_diffusion.c:   for(node=1;node<=E->mesh.nno;node++) {
Advection_diffusion.c:       if(!(E->node[node] & (OFFSIDE | TBX | TBZ | TBY)))
Advection_diffusion.c:   for(node=1;node<=E->mesh.nno;node++) {
Advection_diffusion.c:       if(!(E->node[node] & OFFSIDE ))
Advection_diffusion.c:    const int dims=E->mesh.nsd;
Advection_diffusion.c:    const int dofs=E->mesh.dof;
Advection_diffusion.c:    for(i=1;i<=E->mesh.nno;i++)
Advection_diffusion.c:    for(el=1;el<=E->mesh.nel;el++)    {
Advection_diffusion.c:	  get_global_shape_fn(E,el,&GN,&GNx,&dOmega,0,E->mesh.levmax);
Advection_diffusion.c:	    a1 = E->ien[el].node[a];
Advection_diffusion.c:    for(i=1;i<=E->mesh.nno;i++) {
Advection_diffusion.c: 	  if(E->node[i] & OFFSIDE) continue;
Advection_diffusion.c:	  DTdot[i] *= E->Mass[i];         /* lumped mass matrix */
Advection_diffusion.c:    const int dims=E->mesh.nsd;
Advection_diffusion.c:    const int dofs=E->mesh.dof;
Advection_diffusion.c:    const int lev=E->mesh.levmax;
Advection_diffusion.c:    const int nno=E->mesh.nno;
Advection_diffusion.c:    const int ends=enodes[E->mesh.nsd];
Advection_diffusion.c:    const int vpts=vpoints[E->mesh.nsd];
Advection_diffusion.c:    ienmatrix=E->ien[el].node;
Advection_diffusion.c:      uc1 +=  E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:      uc2 +=  E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:    dx1 = 0.5*(E->X[1][ienmatrix[3]]+E->X[1][ienmatrix[4]]
Advection_diffusion.c:              -E->X[1][ienmatrix[1]]-E->X[1][ienmatrix[2]]);
Advection_diffusion.c:    dx2 = 0.5*(E->X[2][ienmatrix[3]]+E->X[2][ienmatrix[4]]
Advection_diffusion.c:              -E->X[2][ienmatrix[1]]-E->X[2][ienmatrix[2]]);
Advection_diffusion.c:    dx1 = 0.5*(E->X[1][ienmatrix[2]]+E->X[1][ienmatrix[3]]
Advection_diffusion.c:              -E->X[1][ienmatrix[1]]-E->X[1][ienmatrix[4]]);
Advection_diffusion.c:    dx2 = 0.5*(E->X[2][ienmatrix[2]]+E->X[2][ienmatrix[3]]
Advection_diffusion.c:              -E->X[2][ienmatrix[1]]-E->X[2][ienmatrix[4]]);
Advection_diffusion.c:            u1 += VV[1][j] * E->N.vpt[GNVINDEX(j,i)]; 
Advection_diffusion.c:            u2 += VV[2][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:             PG->vpt[GNVINDEX(j,i)] = E->N.vpt[GNVINDEX(j,i)] + adiff * prod1;
Advection_diffusion.c:    const int dims=E->mesh.nsd;
Advection_diffusion.c:    const int dofs=E->mesh.dof;
Advection_diffusion.c:    const int nno=E->mesh.nno;
Advection_diffusion.c:    const int lev=E->mesh.levmax;
Advection_diffusion.c:      node = E->ien[el].node[i];
Advection_diffusion.c:      node = E->ien[el].node[j];
Advection_diffusion.c:	  if(E->node[node] & (TBX | TBY | TBZ))
Advection_diffusion.c:	 	  dT[i] += DT * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:		  sfn = E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:       Q += E->C[E->ien[i].node[j]]; 
Advection_diffusion.c:     Q = Q*E->control.Q0;
Advection_diffusion.c:   Q = (E->rad_heat.total + E->heating_visc[el] - E->heating_adi[el])/E->heating_latent[el];
Advection_diffusion.c:   Q= E->rad_heat.total;
Advection_diffusion.c:                     diff/E->heating_latent[el]*dOmega.vpt[i] 
Advection_diffusion.c:	    if (FLAGS[E->ien[el].node[a]] & FBZ) {
Advection_diffusion.c:		for(aid=0,j=1;j<=onedvpoints[E->mesh.nsd];j++)
Advection_diffusion.c:			    E->M.vpt[GMVINDEX(aid,j)] * g_1d[j].weight[dims-1] *
Advection_diffusion.c:			    BC[2][E->ien[el].node[a]] * E->M.vpt[GMVINDEX(k,j)];
Advection_diffusion.c:    const int dims=E->mesh.nsd;
Advection_diffusion.c:    const int dofs=E->mesh.dof;
Advection_diffusion.c:    const int nno=E->mesh.nno;
Advection_diffusion.c:    const int lev=E->mesh.levmax;
Advection_diffusion.c:	nel=E->mesh.nel;
Advection_diffusion.c:    if(E->advection.fixed_timestep != 0.0) {
Advection_diffusion.c:      E->advection.timestep = E->advection.fixed_timestep;
Advection_diffusion.c:	      ts = E->eco[el].size[1]*E->eco[el].size[1];
Advection_diffusion.c:	      ts = E->eco[el].size[2]*E->eco[el].size[2];
Advection_diffusion.c:      node = E->ien[el].node[i];
Advection_diffusion.c:        VV[1][i] = E->V[1][node];
Advection_diffusion.c:        VV[2][i] = E->V[2][node];
Advection_diffusion.c:        if(dims==3) VV[3][i] = E->V[3][node];
Advection_diffusion.c:        uc1 += E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:        uc2 += E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:        uc3 += E->N.ppt[GNPINDEX(i,1)]*VV[3][i];
Advection_diffusion.c:      uc = fabs(uc1)/E->eco[el].size[1] + fabs(uc2)/E->eco[el].size[2] + fabs(uc3)/E->eco[el].size[3];
Advection_diffusion.c:        uc1 += E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:        uc2 += E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:      uc = fabs(uc1)/E->eco[el].size[1] + fabs(uc2)/E->eco[el].size[2];
Advection_diffusion.c:    adv_timestep = E->advection.fine_tune_dt * adv_timestep;         
Advection_diffusion.c://    adv_timestep =  1.0e-32+min(E->advection.fine_tune_dt*adv_timestep,diff_timestep);
Advection_diffusion.c:    E->advection.timestep = adv_timestep;
Advection_diffusion.c:    const int dims = E->mesh.nsd;
Advection_diffusion.c:    const int lev = E->mesh.levmax;
Advection_diffusion.c:    const int nno = E->mesh.nno;
Advection_diffusion.c:    para1 = E->data.layer_meter*E->data.layer_meter/(E->data.density*E->data.Cp*E->data.ref_temperature*E->data.therm_diff);
Advection_diffusion.c:    E->data.disptn_number = E->data.therm_exp*E->data.grav_acc*E->data.layer_meter/E->data.Cp;
Advection_diffusion.c:  return_horiz_ave(E,E->T,E->Have.T);
Advection_diffusion.c:  if (E->rad_heat.num==0)  {
Advection_diffusion.c:     E->rad_heat.total = para1*E->control.Q0; 
Advection_diffusion.c:     temp1 = 4.6e9-E->monitor.time_scale*E->monitor.elapsed_time;
Advection_diffusion.c:     temp2 = E->rad_heat.percent[0]*E->rad_heat.concen[0]*E->rad_heat.heat_g[0]
Advection_diffusion.c:	         *exp(temp1*log(two)/E->rad_heat.decay_t[0])
Advection_diffusion.c:           + E->rad_heat.percent[1]*E->rad_heat.concen[1]*E->rad_heat.heat_g[1]
Advection_diffusion.c:	         *exp(temp1*log(two)/E->rad_heat.decay_t[1])
Advection_diffusion.c:           + E->rad_heat.percent[2]*E->rad_heat.concen[2]*E->rad_heat.heat_g[2]
Advection_diffusion.c:	         *exp(temp1*log(two)/E->rad_heat.decay_t[2])
Advection_diffusion.c:           + E->rad_heat.percent[3]*E->rad_heat.concen[3]*E->rad_heat.heat_g[3]
Advection_diffusion.c:	         *exp(temp1*log(two)/E->rad_heat.decay_t[3]);
Advection_diffusion.c:     E->rad_heat.total = para1*E->data.density*temp2; 
Advection_diffusion.c:  slope = (E->data.therm_exp_factor-1.0);
Advection_diffusion.c:  temp1 = E->data.disptn_number/E->control.Ra_temp;
Advection_diffusion.c:  for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:    E->heating_latent[e] = 1.0;
Advection_diffusion.c: if (E->control.visc_heating)  {
Advection_diffusion.c:   strain_rate_2_inv(E,E->heating_visc,0);
Advection_diffusion.c:   for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:       temp2 += E->EVi[(e-1)*vpts+i];
Advection_diffusion.c:     E->heating_visc[e] = temp1*temp2*E->heating_visc[e];
Advection_diffusion.c: if (E->control.adi_heating)  {
Advection_diffusion.c:   for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:    ee = (e-1)%E->mesh.elz+1;
Advection_diffusion.c:      j = E->ien[e].node[i];
Advection_diffusion.c:/*      temp2 = temp2 + E->V[2][j]*(E->T[j]+E->control.Ts )*E->data.disptn_number;  */
Advection_diffusion.c:      temp2 = temp2 + E->V[2][j]*((E->Have.T[ee]+E->Have.T[ee+1])*0.5+E->control.Ts )*E->data.disptn_number;
Advection_diffusion.c:    E->heating_adi[e] = temp2*(slope*E->eco[e].centre[2] + 1.0);
Advection_diffusion.c:  if (E->control.Ra_670!=0.0)   {
Advection_diffusion.c:    temp1 = 2.0*E->control.clapeyron670*E->control.Ra_670/(E->control.Ra_temp/E->control.width670);
Advection_diffusion.c:    for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:        j = E->ien[e].node[i];
Advection_diffusion.c:        temp2 = temp2 + temp1*(1.0-E->Fas670[j])*E->Fas670[j]
Advection_diffusion.c:                   *E->V[2][j]*(E->T[j]+E->control.Ts)*E->data.disptn_number;
Advection_diffusion.c:        temp3 = temp3 + temp1*E->control.clapeyron670
Advection_diffusion.c:                        *(1.0-E->Fas670[j])*E->Fas670[j]
Advection_diffusion.c:                        *(E->T[j]+E->control.Ts)*E->data.disptn_number;
Advection_diffusion.c:      E->heating_adi[e] += temp2;
Advection_diffusion.c:      E->heating_latent[e] += temp3;
Advection_diffusion.c:  if (E->control.Ra_410!=0.0)   {
Advection_diffusion.c:    temp1 = 2.0*E->control.clapeyron410*E->control.Ra_410/(E->control.Ra_temp/E->control.width410);
Advection_diffusion.c:    for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:        j = E->ien[e].node[i];
Advection_diffusion.c:        temp2 = temp2 + temp1*(1.0-E->Fas410[j])*E->Fas410[j]
Advection_diffusion.c:                   *E->V[2][j]*(E->T[j]+E->control.Ts)*E->data.disptn_number;
Advection_diffusion.c:        temp3 = temp3 + temp1*E->control.clapeyron410
Advection_diffusion.c:                       *(1.0-E->Fas410[j])*E->Fas410[j]
Advection_diffusion.c:                       *(E->T[j]+E->control.Ts)*E->data.disptn_number;
Advection_diffusion.c:      E->heating_adi[e] += temp2;
Advection_diffusion.c:      E->heating_latent[e] += temp3;
Advection_diffusion.c:  fprintf(E->fp,"QQ %g \n",E->rad_heat.total);
Advection_diffusion.c:if(E->monitor.solution_cycles%1000==0)  {
Advection_diffusion.c:  sprintf(filename,"%s/heating.%d",E->control.data_file,E->monitor.solution_cycles);  
Advection_diffusion.c:  fprintf(fp,"QQ %g %g %g\n",E->control.Ra_temp,E->data.disptn_number,E->rad_heat.total);
Advection_diffusion.c:  for (e=1;e<=E->mesh.nel;e++)
Advection_diffusion.c:    fprintf(fp,"%d %g %g %g\n",e,E->EVi[(e-1)*vpts+1],E->heating_visc[e],E->heating_adi[e]);
Boundary_conditions.c:  for(lv=E->mesh.levmax;lv>=E->mesh.levmin;lv--)  {
Boundary_conditions.c:    if(E->mesh.botvbc == 0) {
Boundary_conditions.c:          horizontal_bc(E,E->VB,1,1,0.0,VBX,0,lv);	 
Boundary_conditions.c:	  horizontal_bc(E,E->VB,1,2,0.0,VBZ,1,lv);
Boundary_conditions.c:	  horizontal_bc(E,E->VB,1,1,E->control.VBXbotval,SBX,1,lv);	 
Boundary_conditions.c:	  horizontal_bc(E,E->VB,1,2,0.0,SBZ,0,lv);
Boundary_conditions.c:	  if(E->mesh.nsd==3)     {
Boundary_conditions.c:	    horizontal_bc(E,E->VB,1,3,E->control.VBYbotval,SBY,1,lv);	
Boundary_conditions.c:	    horizontal_bc(E,E->VB,1,3,0.0,VBY,0,lv);	 
Boundary_conditions.c:    if(E->mesh.topvbc == 0) {
Boundary_conditions.c:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],1,0.0,VBX,0,lv);	 
Boundary_conditions.c:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],2,0.0,VBZ,1,lv);
Boundary_conditions.c:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],1,E->control.VBXtopval,SBX,1,lv); 
Boundary_conditions.c:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],2,0.0,SBZ,0,lv);  
Boundary_conditions.c:	  if(E->mesh.nsd==3)     {
Boundary_conditions.c:	    horizontal_bc(E,E->VB,E->mesh.NOZ[lv],3,E->control.VBYtopval,SBY,1,lv); 
Boundary_conditions.c:	    horizontal_bc(E,E->VB,E->mesh.NOZ[lv],3,0.0,VBY,0,lv);	 
Boundary_conditions.c: if(E->mesh.periodic_x || E->mesh.periodic_y)
Boundary_conditions.c: for(lv=E->mesh.levmax;lv>=E->mesh.levmin;lv--) {
Boundary_conditions.c:     if(E->mesh.botvbc >= 1) {
Boundary_conditions.c:	 horizontal_bc(E,E->VB,1,1,E->control.VBXbotval,VBX,1,lv);	 
Boundary_conditions.c:	 horizontal_bc(E,E->VB,1,2,0.0,VBZ,1,lv);
Boundary_conditions.c:	 horizontal_bc(E,E->VB,1,1,0.0,SBX,0,lv);	 
Boundary_conditions.c:	 horizontal_bc(E,E->VB,1,2,0.0,SBZ,0,lv);
Boundary_conditions.c:	 if(E->mesh.nsd==3) {
Boundary_conditions.c:	     horizontal_bc(E,E->VB,1,3,E->control.VBYbotval,VBY,1,lv);	 
Boundary_conditions.c:	     horizontal_bc(E,E->VB,1,3,0.0,SBY,0,lv);	 
Boundary_conditions.c:      if(E->mesh.topvbc >= 1) {
Boundary_conditions.c:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],1,E->control.VBXtopval,VBX,E->mesh.topvbc,lv);
Boundary_conditions.c:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],2,0.0,VBZ,1,lv);
Boundary_conditions.c:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],1,0.0,SBX,0,lv);	 
Boundary_conditions.c:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],2,0.0,SBZ,0,lv); 
Boundary_conditions.c:	  if(E->mesh.nsd==3) {
Boundary_conditions.c:	      horizontal_bc(E,E->VB,E->mesh.NOZ[lv],3,E->control.VBYtopval,VBY,1,lv);
Boundary_conditions.c:	      horizontal_bc(E,E->VB,E->mesh.NOZ[lv],3,0.0,SBY,0,lv);	 
Boundary_conditions.c:    if (E->control.trechmigrate){
Boundary_conditions.c:        loc_mid = E->control.velo_surf_loc_mid;
Boundary_conditions.c:        loc_mid += E->control.velo_surf_loc_mid_rate*E->monitor.elapsed_time*E->control.timescale;
Boundary_conditions.c:        printf("loc_mid=%f E->control.velo_surf_loc_mid_rate*E->monitor.elapsed_time*E->control.timescale=%f\n",loc_mid,E->control.velo_surf_loc_mid_rate*E->monitor.elapsed_time*E->control.timescale);
Boundary_conditions.c:        for (newnum=1;newnum<=E->mesh.nox;newnum++) {
Boundary_conditions.c:            node = newnum*E->mesh.noz;
Boundary_conditions.c:            if(E->X[1][node]<=loc_mid){
Boundary_conditions.c:                E->VB[1][node] = E->control.velo_surf_mag_left*( tanh( (E->X[1][node])*E->control.velo_surf_width_left )  );
Boundary_conditions.c:                if(E->X[1][node]>=loc_mid-E->control.velo_surf_loc_left_overshoot){
Boundary_conditions.c:                    E->VB[1][node] += E->control.velo_surf_mag_left*sin( (E->X[1][node]-loc_mid+E->control.velo_surf_loc_left_overshoot)/E->control.velo_surf_loc_left_overshoot*3.141592653 );
Boundary_conditions.c:                if(E->X[1][node]>=E->mesh.layer[1]-0.2){
Boundary_conditions.c:                    E->VB[1][node] = E->control.velo_surf_mag_right*( tanh( (E->mesh.layer[1]-E->X[1][node])*E->control.velo_surf_width_right )  );
Boundary_conditions.c:                    E->VB[1][node] = (E->control.velo_surf_mag_right-E->control.velo_surf_mag_left) * tanh( (E->X[1][node]-loc_mid)*E->control.velo_surf_width_mid )   +   E->control.velo_surf_mag_left;
Boundary_conditions.c:    if (E->control.imposevelo){
Boundary_conditions.c:        velosurf = (float *)  malloc((E->mesh.nox+3)*sizeof(float));
Boundary_conditions.c:        age_run = (int)(E->monitor.elapsed_time*E->control.timescale);
Boundary_conditions.c:        sprintf(tempstring,"%s%d%s",E->control.velo_file_pre,E->control.age_total-age_run,E->control.velo_file_post);
Boundary_conditions.c:                E->VB[1][velonum*E->mesh.noz] = velosurf[velonum];
Boundary_conditions.c:                    E->VB[1][velonum*E->mesh.noz] = tanh((E->X[1][velonum*E->mesh.noz])) * velosurf[velonum]; 
Boundary_conditions.c:        for (newnum=velonum+1;newnum<=E->mesh.nox;newnum++) {
Boundary_conditions.c:            E->VB[1][E->mesh.noz*newnum] = velosurf[velonum];
Boundary_conditions.c:            if(newnum>=E->mesh.nox-5)
Boundary_conditions.c:                E->VB[1][newnum*E->mesh.noz] = tanh((E->mesh.layer[1] - E->X[1][E->mesh.noz*newnum])) * velosurf[velonum];
Boundary_conditions.c:    for (node=1;node<=E->mesh.nnov;node++)
Boundary_conditions.c:      fprintf(E->fp,"VB== %d %g %g \n",node,E->VB[1][node],E->VB[2][node]);
Boundary_conditions.c:if (E->control.verbose)     {
Boundary_conditions.c:  if(E->mesh.nsd==3)
Boundary_conditions.c:    for (node=1;node<=E->mesh.nnov;node++)
Boundary_conditions.c:      fprintf(E->fp,"VB== %d %g %g %g\n",node,E->VB[1][node],E->VB[2][node],E->VB[3][node]);
Boundary_conditions.c:    for (node=1;node<=E->mesh.nnov;node++)
Boundary_conditions.c:      fprintf(E->fp,"VB== %d %g %g \n",node,E->VB[1][node],E->VB[2][node]);
Boundary_conditions.c:  for(lv=E->mesh.levmax;lv>=E->mesh.levmin;lv--)    {
Boundary_conditions.c:    fprintf(E->fp,"VBB level=%d %d\n",lv,E->mesh.NNO[lv]);
Boundary_conditions.c:    for (node=1;node<=E->mesh.NNO[lv];node++)
Boundary_conditions.c:      fprintf(E->fp,"VB== %d %u %u %u\n",node,E->NODE[lv][node]&VBX,E->NODE[lv][node]&VBZ,E->NODE[lv][node]&VBY);
Boundary_conditions.c:    if (E->control.imposevelo){
Boundary_conditions.c:  if(E->mesh.botcbc == 1)
Boundary_conditions.c:    { horizontal_bc(E,E->CB,1,2,E->control.CBCbotval,CBZ,1,E->mesh.levmax);	
Boundary_conditions.c:      horizontal_bc(E,E->CB,1,2,E->control.CBCbotval,HBZ,0,E->mesh.levmax); }
Boundary_conditions.c:    { horizontal_bc(E,E->CB,1,2,E->control.CBCbotval,CBZ,0,E->mesh.levmax);	
Boundary_conditions.c:      horizontal_bc(E,E->CB,1,2,E->control.CBCbotval,HBZ,1,E->mesh.levmax); }
Boundary_conditions.c:  if(E->mesh.topcbc == 1)
Boundary_conditions.c:    { horizontal_bc(E,E->CB,E->mesh.noz,2,E->control.CBCtopval,CBZ,1,E->mesh.levmax);	
Boundary_conditions.c:      horizontal_bc(E,E->CB,E->mesh.noz,2,E->control.CBCtopval,HBZ,0,E->mesh.levmax); }
Boundary_conditions.c:    { horizontal_bc(E,E->CB,E->mesh.noz,2,E->control.CBCtopval,CBZ,0,E->mesh.levmax);	
Boundary_conditions.c:      horizontal_bc(E,E->CB,E->mesh.noz,2,E->control.CBCtopval,HBZ,1,E->mesh.levmax); }
Boundary_conditions.c:  if(E->mesh.bottbc == 1)
Boundary_conditions.c:    { horizontal_bc(E,E->TB,1,2,E->control.TBCbotval,TBZ,1,E->mesh.levmax);	
Boundary_conditions.c:      horizontal_bc(E,E->TB,1,2,E->control.TBCbotval,FBZ,0,E->mesh.levmax); }
Boundary_conditions.c:    { horizontal_bc(E,E->TB,1,2,E->control.TBCbotval,TBZ,0,E->mesh.levmax);	
Boundary_conditions.c:      horizontal_bc(E,E->TB,1,2,E->control.TBCbotval,FBZ,1,E->mesh.levmax); }
Boundary_conditions.c:  if(E->mesh.toptbc == 1)
Boundary_conditions.c:    { horizontal_bc(E,E->TB,E->mesh.noz,2,E->control.TBCtopval,TBZ,1,E->mesh.levmax);	
Boundary_conditions.c:      horizontal_bc(E,E->TB,E->mesh.noz,2,E->control.TBCtopval,FBZ,0,E->mesh.levmax); }
Boundary_conditions.c:    { horizontal_bc(E,E->TB,E->mesh.noz,2,E->control.TBCtopval,TBZ,0,E->mesh.levmax);	
Boundary_conditions.c:      horizontal_bc(E,E->TB,E->mesh.noz,2,E->control.TBCtopval,FBZ,1,E->mesh.levmax); }
Boundary_conditions.c:  if(E->mesh.periodic_x || E->mesh.periodic_y)
Boundary_conditions.c:  const int dims=E->mesh.nsd;
Boundary_conditions.c:    for(j=1;j<=E->mesh.noy;j++)
Boundary_conditions.c:      for(i=1;i<=E->mesh.noz;i++)  {
Boundary_conditions.c:        node1 = i + (j-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:        node2 = node1 + (E->mesh.nox-1)*E->mesh.noz;
Boundary_conditions.c:           E->VB[1][node1] = 0.0;
Boundary_conditions.c:           E->VB[1][node2] = 0.0;
Boundary_conditions.c:           if((i != 1) && (i != E->mesh.noz)) {
Boundary_conditions.c:              E->VB[2][node1] = 0.0;  
Boundary_conditions.c:              E->VB[2][node2] = 0.0;
Boundary_conditions.c:  if (E->mesh.nsd == 3) {
Boundary_conditions.c:      for(j=1;j<=E->mesh.nox;j++)
Boundary_conditions.c:        for(i=1;i<=E->mesh.noz;i++)       {
Boundary_conditions.c:          node1 = i + (j-1)*E->mesh.noz;
Boundary_conditions.c:          node2 = node1 +  (E->mesh.noy-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:          if (E->mesh.nsd==3) {
Boundary_conditions.c:              E->VB[3][node2] = 0.0;
Boundary_conditions.c:              E->VB[3][node1] = 0.0;
Boundary_conditions.c:          if((i != 1) && (i != E->mesh.noz)){
Boundary_conditions.c:              E->VB[2][node2] = 0.0;
Boundary_conditions.c:              E->VB[2][node1] = 0.0;
Boundary_conditions.c:  for(level=E->mesh.levmax;level>=E->mesh.levmin;level--) {
Boundary_conditions.c:    noz = E->mesh.NOZ[level] ;
Boundary_conditions.c:    noy = E->mesh.NOY[level] ;
Boundary_conditions.c:    nox = E->mesh.NOX[level] ;
Boundary_conditions.c:            E->NODE[level][node1] = E->NODE[level][node1] | VBX;
Boundary_conditions.c:            E->NODE[level][node1] = E->NODE[level][node1] & (~SBX);
Boundary_conditions.c:               E->NODE[level][node1] = E->NODE[level][node1] & (~VBY);
Boundary_conditions.c:               E->NODE[level][node1] = E->NODE[level][node1] | SBY;
Boundary_conditions.c:               E->NODE[level][node1] = E->NODE[level][node1] & (~ VBZ);
Boundary_conditions.c:               E->NODE[level][node1] = E->NODE[level][node1] | SBZ;    
Boundary_conditions.c:            E->NODE[level][node2] = E->NODE[level][node2] | VBX;
Boundary_conditions.c:            E->NODE[level][node2] = E->NODE[level][node2] & (~SBX);
Boundary_conditions.c:              E->NODE[level][node2] = E->NODE[level][node2] & (~VBY);
Boundary_conditions.c:              E->NODE[level][node2] = E->NODE[level][node2] | SBY;
Boundary_conditions.c:              E->NODE[level][node2] = E->NODE[level][node2] & (~ VBZ);
Boundary_conditions.c:              E->NODE[level][node2] = E->NODE[level][node2] | SBZ;
Boundary_conditions.c:    if (E->mesh.nsd == 3)  {
Boundary_conditions.c:            E->NODE[level][node1] = E->NODE[level][node1] | VBY;
Boundary_conditions.c:            E->NODE[level][node1] = E->NODE[level][node1] & (~SBY);
Boundary_conditions.c:                E->NODE[level][node1] = E->NODE[level][node1] & (~VBZ);
Boundary_conditions.c:                E->NODE[level][node1] = E->NODE[level][node1] | SBZ;
Boundary_conditions.c:                E->NODE[level][node1] = E->NODE[level][node1] & (~VBX);
Boundary_conditions.c:                E->NODE[level][node1] = E->NODE[level][node1] | SBX;
Boundary_conditions.c:            E->NODE[level][node2] = E->NODE[level][node2] | VBY;
Boundary_conditions.c:            E->NODE[level][node2] = E->NODE[level][node2] & (~SBY);
Boundary_conditions.c:                E->NODE[level][node2] = E->NODE[level][node2] & (~VBZ);
Boundary_conditions.c:                E->NODE[level][node2] = E->NODE[level][node2] | SBZ;
Boundary_conditions.c:                E->NODE[level][node2] = E->NODE[level][node2] & (~VBX);
Boundary_conditions.c:                E->NODE[level][node2] = E->NODE[level][node2] | SBX;
Boundary_conditions.c:  const int dims=E->mesh.nsd;
Boundary_conditions.c:    for(j=1;j<=E->mesh.noy;j++)
Boundary_conditions.c:      for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:        node1 = i + (j-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:	node2 = node1 + (E->mesh.nox-1)*E->mesh.noz;
Boundary_conditions.c:          E->node[node1] = E->node[node1] & (~TBX);
Boundary_conditions.c:          E->node[node1] = E->node[node1] | FBX;   
Boundary_conditions.c:          E->TB[1][node1] = 0.0;
Boundary_conditions.c:          E->node[node2] = E->node[node2] & (~TBX);
Boundary_conditions.c:          E->node[node2] = E->node[node2] | FBX;
Boundary_conditions.c:          E->TB[1][node2] = 0.0;
Boundary_conditions.c:  if (E->mesh.nsd == 3)  {  
Boundary_conditions.c:      for(j=1;j<=E->mesh.nox;j++)
Boundary_conditions.c:        for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:          node1 = i + (j-1)*E->mesh.noz;
Boundary_conditions.c:          E->node[node1] = E->node[node1] & (~TBY);
Boundary_conditions.c:	      E->node[node1] = E->node[node1] | FBY;
Boundary_conditions.c:	      E->TB[3][node1] = 0.0;
Boundary_conditions.c:      for(j=1;j<=E->mesh.nox;j++)
Boundary_conditions.c:        for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:          node2 = i +(j-1)*E->mesh.noz + (E->mesh.noy-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:	  E->node[node2] = E->node[node2] & (~TBY);
Boundary_conditions.c:	  E->node[node2] = E->node[node2] | FBY;
Boundary_conditions.c:	  E->TB[3][node2] = 0.0;
Boundary_conditions.c:  const int dims=E->mesh.nsd;
Boundary_conditions.c:    for(j=1;j<=E->mesh.noy;j++)
Boundary_conditions.c:      for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:        node1 = i + (j-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:	node2 = node1 + (E->mesh.nox-1)*E->mesh.noz;
Boundary_conditions.c:          E->node[node1] = E->node[node1] & (~CBX);
Boundary_conditions.c:          E->node[node1] = E->node[node1] | HBX;   
Boundary_conditions.c:          E->CB[1][node1] = 0.0;
Boundary_conditions.c:          E->node[node2] = E->node[node2] & (~CBX);
Boundary_conditions.c:          E->node[node2] = E->node[node2] | HBX;
Boundary_conditions.c:          E->CB[1][node2] = 0.0;
Boundary_conditions.c:  if (E->mesh.nsd == 3)  {  
Boundary_conditions.c:      for(j=1;j<=E->mesh.nox;j++)
Boundary_conditions.c:        for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:          node1 = i + (j-1)*E->mesh.noz;
Boundary_conditions.c:          E->node[node1] = E->node[node1] & (~CBY);
Boundary_conditions.c:	      E->node[node1] = E->node[node1] | HBY;
Boundary_conditions.c:	      E->CB[3][node1] = 0.0;
Boundary_conditions.c:      for(j=1;j<=E->mesh.nox;j++)
Boundary_conditions.c:        for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:          node2 = i +(j-1)*E->mesh.noz + (E->mesh.noy-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:	  E->node[node2] = E->node[node2] & (~CBY);
Boundary_conditions.c:	  E->node[node2] = E->node[node2] | HBY;
Boundary_conditions.c:	  E->CB[3][node2] = 0.0;
Boundary_conditions.c:  const int dims=E->mesh.nsd;
Boundary_conditions.c:  if(dirn > E->mesh.nsd) 
Boundary_conditions.c:      rowl = E->mesh.NOZ[level];
Boundary_conditions.c:       ROW==E->mesh.NOZ[level] ) {
Boundary_conditions.c:      for(j=1;j<=E->mesh.NOY[level];j++)
Boundary_conditions.c:    	for(i=1;i<=E->mesh.NOX[level];i++)     {
Boundary_conditions.c:    	  node = rowl+(i-1)*E->mesh.NOZ[level]+(j-1)*E->mesh.NOX[level]*E->mesh.NOZ[level];
Boundary_conditions.c:    	  E->NODE[level][node] = E->NODE[level][node] & (~ mask);
Boundary_conditions.c:      for(j=1;j<=E->mesh.NOY[level];j++)
Boundary_conditions.c:        for(i=1;i<=E->mesh.NOX[level];i++)       {
Boundary_conditions.c:    	  node = rowl+(i-1)*E->mesh.NOZ[level]+(j-1)*E->mesh.NOX[level]*E->mesh.NOZ[level];
Boundary_conditions.c:    	  E->NODE[level][node] = E->NODE[level][node] | (mask);
Boundary_conditions.c:    	  if(level==E->mesh.levmax){   /* NB */
Boundary_conditions.c:              if(E->X[1][node]>=E->control.velo_surf_loc_mid){
Boundary_conditions.c:                BC[dirn][node] = E->control.velo_surf_mag_right*( tanh( (E->X[1][node]-E->control.velo_surf_loc_mid)*E->control.velo_surf_width_right )  );
Boundary_conditions.c:                if(E->X[1][node]>=E->mesh.layer[1]-E->control.velo_surf_corner_right){
Boundary_conditions.c:                  BC[dirn][node] = E->control.velo_surf_mag_right*( tanh( (E->mesh.layer[1]-E->X[1][node])*E->control.velo_surf_width_right )  );
Boundary_conditions.c:  const int dims=E->mesh.nsd;
Boundary_conditions.c:  fprintf(E->fp,"Periodic boundary conditions\n");
Boundary_conditions.c: const int dims=E->mesh.nsd;
Boundary_conditions.c: fprintf(E->fp,"Periodic temperature boundary conditions\n");
Boundary_conditions.c:    const int dims=E->mesh.nsd;
Boundary_conditions.c:    for(i=1;i<=E->mesh.NNO[level];i++) {
Boundary_conditions.c:        if(E->NODE[level][i] & OFFSIDE)
Boundary_conditions.c:        if ( (E->NODE[level][i] & VBX) != 0 )
Boundary_conditions.c:            Res[ E->ID[level][i].doff[1] ] = 0.0;
Boundary_conditions.c:        if ( (E->NODE[level][i] & VBZ) != 0 )
Boundary_conditions.c:            Res[ E->ID[level][i].doff[2] ] = 0.0;
Boundary_conditions.c:        if (3==dims && ((E->NODE[level][i] & VBY) != 0))
Boundary_conditions.c:            Res[ E->ID[level][i].doff[3] ] = 0.0;
Boundary_conditions.c:    for(node=1;node<=E->mesh.nno;node++)  {
Boundary_conditions.c:	if(E->node[node] & OFFSIDE)
Boundary_conditions.c:	type = (E->node[node] & (TBX | TBZ | TBY));
Boundary_conditions.c:	    E->T[node] = E->TB[1][node];
Boundary_conditions.c:	    E->T[node] = E->TB[2][node];
Boundary_conditions.c:	    E->T[node] = E->TB[3][node];
Boundary_conditions.c:	    E->T[node] = 0.5 * (E->TB[1][node] + E->TB[2][node]);
Boundary_conditions.c:	    E->T[node] = 0.5 * (E->TB[1][node] + E->TB[3][node]);
Boundary_conditions.c:	    E->T[node] = 0.5 * (E->TB[2][node] + E->TB[3][node]);
Boundary_conditions.c:	    E->T[node] = 0.3333333 * (E->TB[1][node] + E->TB[2][node] + E->TB[3][node]);
Boundary_conditions.c:    const int addi_dof = additional_dof[E->mesh.nsd];
Boundary_conditions.c:    const int dofs = E->mesh.dof;
Boundary_conditions.c:    const int nno = E->mesh.nno;
Boundary_conditions.c:    if (E->control.imposevelo){
Boundary_conditions.c:        velosurf = (float *)  malloc((E->mesh.nox+3)*sizeof(float));
Boundary_conditions.c:        age_run = (int)(E->monitor.elapsed_time*E->control.timescale);
Boundary_conditions.c:        sprintf(tempstring,"%s%d%s",E->control.velo_file_pre,E->control.age_total-age_run,E->control.velo_file_post);
Boundary_conditions.c:                E->VB[1][velonum*E->mesh.noz] = velosurf[velonum];
Boundary_conditions.c:                    E->VB[1][velonum*E->mesh.noz] = tanh((E->X[1][velonum*E->mesh.noz])) * velosurf[velonum];                
Boundary_conditions.c:        for (newnum=velonum+1;newnum<=E->mesh.nox;newnum++) {
Boundary_conditions.c:            E->VB[1][E->mesh.noz*newnum] = velosurf[velonum];
Boundary_conditions.c:            if(newnum>=E->mesh.nox-5)
Boundary_conditions.c:                E->VB[1][newnum*E->mesh.noz] = tanh((E->mesh.layer[1] - E->X[1][E->mesh.noz*newnum])) * velosurf[velonum];
Boundary_conditions.c:    if (E->control.trechmigrate){
Boundary_conditions.c:        loc_mid = E->control.velo_surf_loc_mid;
Boundary_conditions.c:        loc_mid += E->control.velo_surf_loc_mid_rate*E->monitor.elapsed_time*E->control.timescale;
Boundary_conditions.c:        printf("loc_mid=%f E->control.velo_surf_loc_mid_rate*E->monitor.elapsed_time*E->control.timescale=%f\n",loc_mid,E->control.velo_surf_loc_mid_rate*E->monitor.elapsed_time*E->control.timescale);
Boundary_conditions.c:        for (newnum=1;newnum<=E->mesh.nox;newnum++) {
Boundary_conditions.c:            node = newnum*E->mesh.noz;
Boundary_conditions.c:            if(E->X[1][node]<=loc_mid){
Boundary_conditions.c:                E->VB[1][node] = E->control.velo_surf_mag_left*( tanh( (E->X[1][node])*E->control.velo_surf_width_left )  );
Boundary_conditions.c:                if(E->X[1][node]>=loc_mid-E->control.velo_surf_loc_left_overshoot){
Boundary_conditions.c:                    E->VB[1][node] += E->control.velo_surf_mag_left*sin( (E->X[1][node]-loc_mid+E->control.velo_surf_loc_left_overshoot)/E->control.velo_surf_loc_left_overshoot*3.141592653 );
Boundary_conditions.c:                if(E->X[1][node]>=E->mesh.layer[1]-0.2){
Boundary_conditions.c:                    E->VB[1][node] = E->control.velo_surf_mag_right*( tanh( (E->mesh.layer[1]-E->X[1][node])*E->control.velo_surf_width_right )  );
Boundary_conditions.c:                    E->VB[1][node] = (E->control.velo_surf_mag_right-E->control.velo_surf_mag_left) * tanh( (E->X[1][node]-loc_mid)*E->control.velo_surf_width_mid )   +   E->control.velo_surf_mag_left;
Boundary_conditions.c:	if(E->node[node] & OFFSIDE)
Boundary_conditions.c:        if (E->node[node] & typex)  
Boundary_conditions.c:	      U[E->id[node].doff[1]] = E->VB[1][node]; 
Boundary_conditions.c:	if (E->node[node] & typez)  
Boundary_conditions.c:	      U[E->id[node].doff[2]] = E->VB[2][node]; 
Boundary_conditions.c: 	if (3==dofs && E->node[node] & typey)  
Boundary_conditions.c:	      U[E->id[node].doff[3]] = E->VB[3][node]; 
Boundary_conditions.c:    if (E->control.imposevelo){
Composition_adv.c:  for(j=1;j<=E->mesh.nsd;j++)   {
Composition_adv.c:    Vpred[j] = (float *) malloc ((E->advection.markers+1)*sizeof(float));
Composition_adv.c:  velocity_markers(E,Vpred,V,XMCpred,E->CElement);
Composition_adv.c:  for (i=1;i<=E->advection.markers;i++)   {
Composition_adv.c:    XMC[1][i] = XMC[1][i] + 0.5*E->advection.timestep*(VO[1][i]+Vpred[1][i]);
Composition_adv.c:    XMC[2][i] = XMC[2][i] + 0.5*E->advection.timestep*(VO[2][i]+Vpred[2][i]);
Composition_adv.c:    XMC[1][i] = min(XMC[1][i],E->XP[1][E->mesh.nox]);
Composition_adv.c:    XMC[1][i] = max(XMC[1][i],E->XP[1][1]);
Composition_adv.c:    XMC[2][i] = min(XMC[2][i],E->XP[2][E->mesh.noz]);
Composition_adv.c:    XMC[2][i] = max(XMC[2][i],E->XP[2][1]);
Composition_adv.c:  element_markers(E,XMC,E->CElement);
Composition_adv.c:  get_C_from_markers(E,C,E->CElement);
Composition_adv.c:  if(E->control.phasevisc_C)
Composition_adv.c:    Cphase_markers(E,Cphase,XMC,E->CElement);
Composition_adv.c:  for(j=1;j<=E->mesh.nsd;j++)  {  
Composition_adv.c:  velocity_markers(E,VO,V,XMC,E->CElement);
Composition_adv.c:  for (i=1;i<=E->advection.markers;i++)  {
Composition_adv.c:    XMCpred[1][i] = XMC[1][i] + E->advection.timestep*VO[1][i];
Composition_adv.c:    XMCpred[2][i] = XMC[2][i] + E->advection.timestep*VO[2][i];
Composition_adv.c:    XMCpred[1][i] = min(XMCpred[1][i],E->XP[1][E->mesh.nox]);
Composition_adv.c:    XMCpred[1][i] = max(XMCpred[1][i],E->XP[1][1]);
Composition_adv.c:    XMCpred[2][i] = min(XMCpred[2][i],E->XP[2][E->mesh.noz]);
Composition_adv.c:    XMCpred[2][i] = max(XMCpred[2][i],E->XP[2][1]);
Composition_adv.c:  element_markers(E,XMCpred,E->CElement);
Composition_adv.c:  get_C_from_markers(E,C,E->CElement);
Composition_adv.c:  if(E->control.phasevisc_C)
Composition_adv.c:    Cphase_markers(E,Cphase,XMCpred,E->CElement);
Composition_adv.c:  const int elx=E->mesh.elx;
Composition_adv.c:  const int elz=E->mesh.elz;
Composition_adv.c:  const int ely=E->mesh.ely;
Composition_adv.c:  const int nox=E->mesh.nox;
Composition_adv.c:  const int noz=E->mesh.noz;
Composition_adv.c:  const int nno=E->mesh.nno;
Composition_adv.c:  const int nel=E->mesh.nel;
Composition_adv.c:  const int dims=E->mesh.nsd;
Composition_adv.c:  const int lev=E->mesh.levmax;
Composition_adv.c:  for (imark=1;imark<=E->advection.markers;imark++)   {
Composition_adv.c:    element[E->C12[imark]][Element[imark]] ++; 
Composition_adv.c:       temp3 = E->CE[el];    /* elemental C */
Composition_adv.c:       node = E->ien[el].node[j];
Composition_adv.c:       C[node] += E->TWW[lev][el].node[j] * temp3;
Composition_adv.c:    E->CE[el] = temp3;
Composition_adv.c:     C[node] = C[node]*E->Mass[node];
Composition_adv.c:  const int elx=E->mesh.elx;
Composition_adv.c:  const int elz=E->mesh.elz;
Composition_adv.c:  const int ely=E->mesh.ely;
Composition_adv.c:  const int nox=E->mesh.nox;
Composition_adv.c:  const int noz=E->mesh.noz;
Composition_adv.c:  const int nno=E->mesh.nno;
Composition_adv.c:  const int nel=E->mesh.nel;
Composition_adv.c:  const int dims=E->mesh.nsd;
Composition_adv.c:  const int lev=E->mesh.levmax;
Composition_adv.c:  for (i=1;i<=E->advection.markers;i++)   {
Composition_adv.c:    el = get_element(E,E->XMC[1][i],XMC[2][i],dX);
Composition_adv.c:    weigh1 = (E->eco[el].size[1]-dX[1])*(E->eco[el].size[2]-dX[2]);
Composition_adv.c:    weigh4 = dX[1]*(E->eco[el].size[2]-dX[2]);
Composition_adv.c:    weigh2 = (E->eco[el].size[1]-dX[1])*dX[2];
Composition_adv.c:    area = E->eco[el].size[1]*E->eco[el].size[2];
Composition_adv.c:    T = (weigh1*E->T[E->ien[el].node[1]] + weigh2*E->T[E->ien[el].node[2]] 
Composition_adv.c:              + weigh3*E->T[E->ien[el].node[3]] + weigh4*E->T[E->ien[el].node[4]])
Composition_adv.c:    e_pressure = E->viscosity.zlm - XMC[2][i] - E->control.clapeyron670*(T-E->control.transT670);
Composition_adv.c:    Bvisc = pt5 * (one + tanh(E->control.width670 * e_pressure));
Composition_adv.c:  E->advection.markerIX=1;
Composition_adv.c:  E->advection.markerIZ=1;
Composition_adv.c:  for (i=1;i<=E->advection.markers;i++)  {
Composition_adv.c:  sprintf(filename1,"markers%d.%d",E->advection.timesteps,onf);
Composition_adv.c:  for (i=1;i<=E->advection.markers;i++)  {
Composition_adv.c:    weigh1 = (E->eco[el].size[1]-dX[1])*(E->eco[el].size[2]-dX[2]);
Composition_adv.c:    weigh4 = dX[1]*(E->eco[el].size[2]-dX[2]);
Composition_adv.c:    weigh2 = (E->eco[el].size[1]-dX[1])*dX[2];
Composition_adv.c:    area = E->eco[el].size[1]*E->eco[el].size[2];
Composition_adv.c:    V1[1][i] = (weigh1*V[1][E->ien[el].node[1]] + weigh2*V[1][E->ien[el].node[2]] 
Composition_adv.c:              + weigh3*V[1][E->ien[el].node[3]] + weigh4*V[1][E->ien[el].node[4]])
Composition_adv.c:    V1[2][i] = (weigh1*V[2][E->ien[el].node[1]] + weigh2*V[2][E->ien[el].node[2]] 
Composition_adv.c:              + weigh3*V[2][E->ien[el].node[3]] + weigh4*V[2][E->ien[el].node[4]])
Composition_adv.c:if (i<1200)fprintf(E->fp,"%d %d %g %g %g %g %g %g %g %g\n",i,el,E->eco[el].size[1],E->eco[el].size[2],dX[1],dX[2],XMC[1][i],XMC[2][i],V1[1][i],V1[2][i]);
Composition_adv.c:if (i<1200)fprintf(E->fp,"V1 %d %d %g %g %g %g\n",i,el,V[1][E->ien[el].node[1]],V[1][E->ien[el].node[2]],V[1][E->ien[el].node[3]],V[1][E->ien[el].node[4]]);
Composition_adv.c:if (i<1200)fprintf(E->fp,"V2 %d %d %g %g %g %g\n",i,el,V[2][E->ien[el].node[1]],V[2][E->ien[el].node[2]],V[2][E->ien[el].node[3]],V[2][E->ien[el].node[4]]);
Composition_adv.c:  const int nox = E->mesh.nox;
Composition_adv.c:  const int noz = E->mesh.noz;
Composition_adv.c:  const int elx = E->mesh.elx;
Composition_adv.c:  const int elz = E->mesh.elz;
Composition_adv.c:    dx = E->XP[1][nox]/elx;
Composition_adv.c:      fprintf(E->fp,"%g\n",E->XP[2][i]);
Composition_adv.c:      fprintf(E->fp,"%g\n",E->XP[1][i]);
Composition_adv.c:  E->advection.markerIX = min(XMC1/dx+1,elx);
Composition_adv.c:  dX[1] = XMC1-E->XP[1][E->advection.markerIX];
Composition_adv.c:    if (XMC2>=E->XP[2][i])  {
Composition_adv.c:       if (XMC2<=E->XP[2][i+1])  {
Composition_adv.c:          E->advection.markerIZ = i;
Composition_adv.c:          dX[2] = XMC2-E->XP[2][i];
Composition_adv.c:  el = E->advection.markerIZ + (E->advection.markerIX-1)*elz;
Composition_adv.c:       fprintf(E->fp,"!!!overflow %g %g %d\n",XMC1,XMC2,el); fflush(E->fp);
Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:  for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:    elz = E->mesh.ELZ[lev];
Construct_arrays.c:    ely = E->mesh.ELY[lev];
Construct_arrays.c:    noz = E->mesh.NOZ[lev];
Construct_arrays.c:    noy = E->mesh.NOY[lev];
Construct_arrays.c:    nox = E->mesh.NOX[lev];
Construct_arrays.c:    elx = E->mesh.ELX[lev];
Construct_arrays.c:    nel=E->mesh.NEL[lev];
Construct_arrays.c:    nno=E->mesh.NNO[lev];
Construct_arrays.c:		         E->IEN[lev][element].node[rr]= start 
Construct_arrays.c:      E->NEI[lev].nels[i] = 0;
Construct_arrays.c:        node=E->IEN[lev][e].node[a];
Construct_arrays.c:	    E->NEI[lev].nels[node]++;
Construct_arrays.c:        E->NEI[lev].element[(node-1)*ends+E->NEI[lev].nels[node]-1] = e;
Construct_arrays.c:	    E->NEI[lev].lnode[(node-1)*ends+E->NEI[lev].nels[node]-1] = a;
Construct_arrays.c:    for(element=1;element<=E->mesh.NEL[E->mesh.levmax];element++)
Construct_arrays.c:      if ( (element-1)%E->mesh.elz==0) {
Construct_arrays.c:        E->sien[e].node[1] = (E->ien[element].node[1]-1)/E->mesh.noz+1;
Construct_arrays.c:        E->sien[e].node[2] = (E->ien[element].node[4]-1)/E->mesh.noz+1;
Construct_arrays.c:          E->sien[e].node[3] = (E->ien[element].node[8]-1)/E->mesh.noz+1;
Construct_arrays.c:          E->sien[e].node[4] = (E->ien[element].node[5]-1)/E->mesh.noz+1;
Construct_arrays.c:        E->surf_element[e] = element;
Construct_arrays.c:    E->mesh.snel = e;
Construct_arrays.c:    for (i=1;i<=E->mesh.nsf;i++)
Construct_arrays.c:      E->surf_node[i] = i*E->mesh.noz;
Construct_arrays.c:if (E->control.verbose) 
Construct_arrays.c:  for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:     fprintf(E->fp,"output_IEN_arrays %d\n",lev);
Construct_arrays.c:        for (i=1;i<=E->mesh.NEL[lev];i++)
Construct_arrays.c:           fprintf(E->fp,"%d %d %d %d %d\n",i,E->IEN[lev][i].node[1],E->IEN[lev][i].node[2],E->IEN[lev][i].node[3],E->IEN[lev][i].node[4]);
Construct_arrays.c:        for (i=1;i<=E->mesh.NEL[lev];i++)
Construct_arrays.c:           fprintf(E->fp,"%d %d %d %d %d %d %d %d %d\n",i,E->IEN[lev][i].node[1],E->IEN[lev][i].node[2],E->IEN[lev][i].node[3],E->IEN[lev][i].node[4],E->IEN[lev][i].node[5],E->IEN[lev][i].node[6],E->IEN[lev][i].node[7],E->IEN[lev][i].node[8]);
Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:    for(lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:      elz = E->mesh.ELZ[lev];
Construct_arrays.c:      ely = E->mesh.ELY[lev];
Construct_arrays.c:      noz=E->mesh.NOZ[lev];
Construct_arrays.c:      noy=E->mesh.NOY[lev];
Construct_arrays.c:      for(node=1;node<=E->mesh.NNO[lev];node++)
Construct_arrays.c:              E->ID[lev][node].doff[doff] = eqn_count;
Construct_arrays.c:      E->mesh.NEQ[lev] = eqn_count;
Construct_arrays.c:    E->mesh.neq = E->mesh.NEQ[E->mesh.levmax];  /*  Total NUMBER of independent variables  */
Construct_arrays.c:if (E->control.verbose)
Construct_arrays.c:  for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:      fprintf(E->fp,"output_ID_arrays %d\n",lev);
Construct_arrays.c:        for (i=1;i<=E->mesh.NNO[lev];i++)
Construct_arrays.c:          fprintf(E->fp,"%d %d %d \n",i,E->ID[lev][i].doff[1],E->ID[lev][i].doff[2]);
Construct_arrays.c:        for (i=1;i<=E->mesh.NNO[lev];i++)
Construct_arrays.c:          fprintf(E->fp,"%d %d %d %d\n",i,E->ID[lev][i].doff[1],E->ID[lev][i].doff[2],E->ID[lev][i].doff[3]);
Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:  for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Construct_arrays.c:    nel=E->mesh.NEL[lev];
Construct_arrays.c:	           E->LMD[lev][e].node[a].doff[1] = E->ID[lev][E->IEN[lev][e].node[a]].doff[1]; 
Construct_arrays.c:	           E->LMD[lev][e].node[a].doff[2] = E->ID[lev][E->IEN[lev][e].node[a]].doff[2]; 
Construct_arrays.c:                      E->LMD[lev][e].node[a].doff[3] = E->ID[lev][E->IEN[lev][e].node[a]].doff[3]; 
Construct_arrays.c:  if(E->control.verbose) 
Construct_arrays.c:        for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Construct_arrays.c:          fprintf(E->fp,"output_LM_arrays %d\n",lev);
Construct_arrays.c:          nel=E->mesh.NEL[lev];
Construct_arrays.c:	      fprintf(E->fp,"%d %d %d %d %d\n",e,a,E->LMD[lev][e].node[a].doff[1],E->LMD[lev][e].node[a].doff[2],E->LMD[lev][e].node[a].doff[3]); 
Construct_arrays.c:     else if(E->mesh.nsd==2)
Construct_arrays.c:        for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Construct_arrays.c:          fprintf(E->fp,"output_LM_arrays %d\n",lev);
Construct_arrays.c:          nel=E->mesh.NEL[lev];
Construct_arrays.c:	      fprintf(E->fp,"%d %d %d %d\n",e,a,E->LMD[lev][e].node[a].doff[1],E->LMD[lev][e].node[a].doff[2]); 
Construct_arrays.c:  fflush(E->fp);
Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:    for(lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)   {
Construct_arrays.c:       neq=E->mesh.NEQ[lev];
Construct_arrays.c:       nno=E->mesh.NNO[lev];
Construct_arrays.c:       E->Node_map[lev]=(int *) malloc ((nno+5)*max_eqn*sizeof(int));
Construct_arrays.c:	   E->Node_map[lev][i] = neq+1;  /* DANGER !!! */
Construct_arrays.c:	   E->Node_eqn[lev][i] = 0;
Construct_arrays.c:	   if(E->NODE[lev][nn] & OFFSIDE)
Construct_arrays.c:	   for(el=1;el<=E->NEI[lev].nels[nn];el++)  {
Construct_arrays.c:	       element = E->NEI[lev].element[(nn-1)*ends+el-1]; 
Construct_arrays.c:		   node1=E->IEN[lev][element].node[n]; /*global node number*/
Construct_arrays.c:		       eqn1=E->ID[lev][node1].doff[i];
Construct_arrays.c:			   if(E->Node_map[lev][loc1+j] == eqn1) { /* found, index next equation */
Construct_arrays.c:			   E->Node_map[lev][loc1+count] = eqn1;
Construct_arrays.c:/* fprintf(E->fp,"%d %d %d \n",nn,E->NEI[lev].nels[nn],count); 
Construct_arrays.c:           E->Node_eqn[lev][nn] = loc1;
Construct_arrays.c:       E->Node_eqn[lev][nno+1] = loc1;       /* mark the end of Node_eqn */
Construct_arrays.c:	   if(E->NODE[lev][nn] & OFFSIDE)
Construct_arrays.c:	   E->Node_k_id[lev][nn] = loc1;
Construct_arrays.c: 	   loc1 += (E->Node_eqn[lev][nn+1]-E->Node_eqn[lev][nn]) * dims;
Construct_arrays.c:       E->Eqn_k[lev] = (higher_precision *) malloc ((loc1+5) * sizeof(higher_precision));
Construct_arrays.c:       E->mesh.matrix_size[lev] = loc1 + 1;
Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:    const int lms=loc_mat_size[E->mesh.nsd];
Construct_arrays.c:    for(level=E->mesh.levmax;level>=E->mesh.levmin;level--)   {
Construct_arrays.c:	neq=E->mesh.NEQ[level];
Construct_arrays.c:	nel=E->mesh.NEL[level];
Construct_arrays.c:	nno=E->mesh.NNO[level];
Construct_arrays.c:	    E->BI[level][i] = 0.0; 
Construct_arrays.c:    for(i=0;i<=E->mesh.matrix_size[level];i++) 
Construct_arrays.c:        E->Eqn_k[level][i] = 0.0; 
Construct_arrays.c:	    if (E->control.augmented_Lagr)
Construct_arrays.c:		node=E->IEN[level][element].node[i];
Construct_arrays.c:		if(E->NODE[level][node] & OFFSIDE)
Construct_arrays.c:		loc0=E->Node_eqn[level][node];
Construct_arrays.c:		max_eqn = E->Node_eqn[level][node+1] - E->Node_eqn[level][node];
Construct_arrays.c:		loc1=E->Node_k_id[level][node];
Construct_arrays.c:		loc2=loc1+(E->LMD[level][element].node[i].doff[2]
Construct_arrays.c:			  -E->LMD[level][element].node[i].doff[1])*max_eqn;
Construct_arrays.c:		if (3==dims) loc3=loc1+(E->LMD[level][element].node[i].doff[3]
Construct_arrays.c:			         -E->LMD[level][element].node[i].doff[1])*max_eqn;
Construct_arrays.c:		if(E->NODE[level][node] & VBX) w1=0.0;
Construct_arrays.c:		if(E->NODE[level][node] & VBZ) w2=0.0;
Construct_arrays.c:		if(E->NODE[level][node] & VBY) w3=0.0;
Construct_arrays.c:		    node1=E->IEN[level][element].node[j];
Construct_arrays.c:		    eqn1=E->LMD[level][element].node[j].doff[1];
Construct_arrays.c:		    eqn2=E->LMD[level][element].node[j].doff[2];
Construct_arrays.c:		    if(3==dims) eqn3=E->LMD[level][element].node[j].doff[3];
Construct_arrays.c:		    if(E->NODE[level][node1] & VBX) ww1=0.0;
Construct_arrays.c:		    if(E->NODE[level][node1] & VBZ) ww2=0.0;
Construct_arrays.c:		    if(E->NODE[level][node1] & VBY) ww3=0.0; 
Construct_arrays.c:			if(E->Node_map[level][loc0+k] == eqn1) { /* found, index next equation */
Construct_arrays.c:		    E->Eqn_k[level][loc1+index] +=  w1*ww1*elt_K[pp*lms+qq]; /* direction 1 */
Construct_arrays.c:		    E->Eqn_k[level][loc2+index] +=  w2*ww1*elt_K[(pp+1)*lms+qq]; /* direction 1 */
Construct_arrays.c:		    if(3==dims) E->Eqn_k[level][loc3+index] +=  w3*ww1*elt_K[(pp+2)*lms+qq]; /* direction 1 */
Construct_arrays.c:			if(E->Node_map[level][loc0+k] == eqn2) { /* found, index next equation */
Construct_arrays.c:		    E->Eqn_k[level][loc1+index] += w1*ww2*elt_K[pp*lms+qq+1]; /* direction 1 */
Construct_arrays.c:		    E->Eqn_k[level][loc2+index] += w2*ww2*elt_K[(pp+1)*lms+qq+1]; /* direction 2 */
Construct_arrays.c:		    if(3==dims) E->Eqn_k[level][loc3+index] += w3*ww2*elt_K[(pp+2)*lms+qq+1]; /* direction 3 */
Construct_arrays.c:			    if(E->Node_map[level][loc0+k] == eqn3) { /* found, index next equation */
Construct_arrays.c:			E->Eqn_k[level][loc1+index] += w1*ww3*elt_K[pp*lms+qq+2]; /* direction 1 */
Construct_arrays.c:			E->Eqn_k[level][loc2+index] += w2*ww3*elt_K[(pp+1)*lms+qq+2]; /* direction 2 */
Construct_arrays.c:			E->Eqn_k[level][loc3+index] += w3*ww3*elt_K[(pp+2)*lms+qq+2]; /* direction 3 */
Construct_arrays.c:            if(E->BI[level][j] ==0.0)  fprintf(stderr,"level %d, equation %d/%d has zero diagonal term\n",level,j,neq);
Construct_arrays.c:	    assert( E->BI[level][j] != 0 /* diagonal of matrix = 0, not acceptable */);
Construct_arrays.c:            E->BI[level][j]  = (float) 1.0/E->BI[level][j];   
Construct_arrays.c:      if (E->control.verbose)   {
Construct_arrays.c:        fprintf(E->fp,"level %d\n",level);
Construct_arrays.c:            if(E->NODE[level][j] & OFFSIDE)
Construct_arrays.c:            eqn1=E->ID[level][j].doff[1];
Construct_arrays.c:            eqn2=E->ID[level][j].doff[2];
Construct_arrays.c:            max_eqn = E->Node_eqn[level][j+1]-E->Node_eqn[level][j];
Construct_arrays.c:            B1=E->Eqn_k[level]+E->Node_k_id[level][j];
Construct_arrays.c:            B2=E->Eqn_k[level]+E->Node_k_id[level][j]+max_eqn;
Construct_arrays.c:                fprintf(E->fp,"%d %d %g %g\n",j,i,B1[i],B2[i]);
Construct_arrays.c:  for(lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--){
Construct_arrays.c:      elz = E->mesh.ELZ[lev];
Construct_arrays.c:      ely = E->mesh.ELY[lev];
Construct_arrays.c:      elx = E->mesh.ELX[lev];
Construct_arrays.c:      noy = E->mesh.NOY[lev];
Construct_arrays.c:      noz = E->mesh.NOZ[lev];
Construct_arrays.c:      nno = E->mesh.NNO[lev];
Construct_arrays.c:      for(i=1;i<=E->mesh.NNO[lev];i++)
Construct_arrays.c:          E->TW[lev][i] = 0.0;
Construct_arrays.c:                  for(l=1;l<=enodes[E->mesh.nsd];l++) {
Construct_arrays.c:                      node = E->IEN[lev][elt].node[l];
Construct_arrays.c:                      E->TW[lev][node] += 1.0;
Construct_arrays.c:      for(i=1;i<=E->mesh.NNO[lev];i++) {
Construct_arrays.c:          if(E->NODE[lev][i] & OFFSIDE)
Construct_arrays.c:          assert( E->TW[lev][i] != 0.0  /* setting weightings failed */);
Construct_arrays.c:          E->TW[lev][i] = 1.0/(E->TW[lev][i]);
Construct_arrays.c:  for(i=1;i<=E->mesh.nox;i++)   /* Horizontal  */
Construct_arrays.c:    { for(j=1;j<=E->mesh.noy;j++)
Construct_arrays.c:        { node = 1+(i-1)*E->mesh.noz+(j-1)*E->mesh.noz*E->mesh.nox;
Construct_arrays.c:          E->node[node] = E->node[node] | TZEDGE;
Construct_arrays.c:          E->node[node] = E->node[node] | VZEDGE;
Construct_arrays.c:          node += E->mesh.noz-1;;
Construct_arrays.c:          E->node[node] = E->node[node] | VZEDGE;
Construct_arrays.c:          E->node[node] = E->node[node] | TZEDGE;
Construct_arrays.c:  if (E->mesh.nsd == 3) /* not appropriate otherwise */
Construct_arrays.c:    for(i=1;i<=E->mesh.noz;i++) /* vertical edge, x normal */
Construct_arrays.c:      { for(j=1;j<=E->mesh.noy;j++)
Construct_arrays.c:          { node = i + (j-1) * E->mesh.nox * E->mesh.noz;
Construct_arrays.c:            E->node[node] = E->node[node] | TXEDGE;
Construct_arrays.c:            E->node[node] = E->node[node] | VXEDGE;
Construct_arrays.c:            node = i+(E->mesh.nox-1)*E->mesh.noz + (j-1) * E->mesh.nox * E->mesh
Construct_arrays.c:            E->node[node] = E->node[node] | TXEDGE;
Construct_arrays.c:            E->node[node] = E->node[node] | VXEDGE; } }
Construct_arrays.c:  for(i=1;i<=E->mesh.noz;i++)   /* vertical edge, y normal */
Construct_arrays.c:    { for(j=1;j<=E->mesh.nox;j++)
Construct_arrays.c:        { node = i + (j-1) * E->mesh.noz;
Construct_arrays.c:          E->node[node] = E->node[node] | TYEDGE;
Construct_arrays.c:          E->node[node] = E->node[node] | VYEDGE;
Construct_arrays.c:          node = i+(E->mesh.noy-1)*E->mesh.noz*E->mesh.nox + (j-1) * E->mesh.noz
Construct_arrays.c:          E->node[node] = E->node[node] | TYEDGE;
Construct_arrays.c:          E->node[node] = E->node[node] | VYEDGE; } }
Construct_arrays.c:     for(lev=E->mesh.levmax-1;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:      elx = E->mesh.ELX[lev];
Construct_arrays.c:	  elz = E->mesh.ELZ[lev];
Construct_arrays.c:	  ely = E->mesh.ELY[lev];
Construct_arrays.c:		  for(l=1;l<=enodes[E->mesh.nsd];l++)   {
Construct_arrays.c:		      E->EL[lev][elt].sub[l] = eltu
Construct_arrays.c:    const int dims=E->mesh.nsd;
Construct_arrays.c:    const int n=loc_mat_size[E->mesh.nsd];
Construct_arrays.c:    if(E->control.verbose )
Construct_arrays.c:    for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Construct_arrays.c:	for(el=1;el<=E->mesh.NEL[lev];el++)    {
Construct_arrays.c:	    get_elt_k(E,el,E->elt_k[lev][el].k,lev,0);  /* not for penalty */ 
Construct_arrays.c:	    if (E->control.augmented_Lagr)
Construct_arrays.c:	        get_aug_k(E,el,E->elt_k[lev][el].k,lev,0);
Construct_arrays.c:        build_diagonal_of_K(E,el,E->elt_k[lev][el].k,lev);
Construct_arrays.c:            for(j=0;j<E->mesh.NEQ[lev];j++) {
Construct_arrays.c:	       if(E->BI[lev][j] ==0.0)  fprintf(stderr,"level %d, equation %d/%d has zero diagonal term\n",lev,j,E->mesh.NEQ[lev]);
Construct_arrays.c:               assert( E->BI[lev][j] != 0 /* diagonal of matrix = 0, not acceptable */);
Construct_arrays.c:               E->BI[lev][j]  = (float) 1.0/E->BI[lev][j];    
Construct_arrays.c: if (E->control.verbose) 
Construct_arrays.c:    for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Construct_arrays.c:	for(el=1;el<=E->mesh.NEL[lev];el++)
Construct_arrays.c:             for(j=1;j<=enodes[E->mesh.nsd];j++)
Construct_arrays.c:		 for(k=1;k<=enodes[E->mesh.nsd];k++) {
Construct_arrays.c:	/*  fprintf(E->fp,"stiff_for_e %d %d %d %g %g %g %g \n",el,j,k,E->elt_k[lev][el].k[ii],E->elt_k[lev][el].k[ii+1],E->elt_k[lev][el].k[ii+n],E->elt_k[lev][el].k[ii+n+1]);      */
Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:  if(E->control.verbose)
Construct_arrays.c:  for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Construct_arrays.c:    for(el=1;el<=E->mesh.NEL[lev];el++)       {
Construct_arrays.c:      get_elt_g(E,el,E->elt_del[lev][el].g,lev);  
Construct_arrays.c:  const int  dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:  for (el=1; el<=E->mesh.nel; el++)  {
Construct_arrays.c:    E->mat[el] = 1;
Construct_arrays.c:       nodea = E->ien[el].node[a];
Construct_arrays.c:       x2 += E->X[2][nodea];
Construct_arrays.c:         E->mat[el]=llayer;
Construct_arrays.c:  for (el=1; el<=E->mesh.nel; el++)
Construct_arrays.c:    fprintf(E->fp,"mat[%d]= %d \n",el,E->mat[el]);
Construct_arrays.c:   for (i=E->mesh.levmin;i<=E->mesh.levmax;i++)
Construct_arrays.c:    if(!E->control.NMULTIGRID && !E->control.NASSEMBLE)  {
Construct_arrays.c:       E->elt_k[i]=(struct EK *)malloc((E->mesh.NEL[i]+1)*sizeof(struct EK));
Construct_arrays.c:    else if(E->control.NMULTIGRID || E->control.NASSEMBLE) {
Construct_arrays.c:       E->Node_eqn[i]  = (int *) malloc((E->mesh.NNO[i]+5) * sizeof(int));
Construct_arrays.c:       E->Node_k_id[i] = (int *) malloc((E->mesh.NNO[i]+5) * sizeof(int));
Construct_arrays.c:  if (been_here0 == 0 || E->viscosity.update_allowed)   {
Construct_arrays.c:    if (E->control.NMULTIGRID)
Construct_arrays.c:    if (E->control.NMULTIGRID || E->control.NASSEMBLE) {
Construct_arrays.c:    for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)   
Convection.c:   input_int("composition",&(E->control.composition),"0");
Convection.c:   input_float("comp_diffusivity",&(E->control.comp_diff),"0");
Convection.c:   input_string("comp_adv_method",E->control.comp_adv_method,NULL);
Convection.c:   input_int("composition_phasechange",&(E->control.composition_phasechange),"0");
Convection.c:    if (E->control.composition && strcmp(E->control.comp_adv_method,"field")==0)
Convection.c:      E->next_buoyancy_field = PG_timestep;
Convection.c:    else if (E->control.composition && strcmp(E->control.comp_adv_method,"particle")==0)  {
Convection.c:      E->next_buoyancy_field = PG_timestep_particle;
Convection.c:      E->next_buoyancy_field = PG_timestep;
Convection.c:    E->special_process_new_buoyancy = twiddle_thumbs; 
Convection.c:    E->problem_settings = read_convection_settings;
Convection.c:    E->problem_derived_values = convection_derived_values;
Convection.c:    E->problem_allocate_vars = convection_allocate_memory;
Convection.c:    E->problem_boundary_conds = convection_boundary_conditions;
Convection.c:    E->problem_initial_fields = convection_initial_fields;
Convection.c:    E->problem_node_positions = node_locations;
Convection.c:    E->problem_update_node_positions = twiddle_thumbs;
Convection.c:    E->problem_update_bcs = twiddle_thumbs;
Convection.c:    sprintf(E->control.which_data_files,"Temp,Strf,Pres");
Convection.c:    sprintf(E->control.which_horiz_averages,"Temp,Visc,Vrms");
Convection.c:    sprintf(E->control.which_running_data,"Step,Time,");
Convection.c:    sprintf(E->control.which_observable_data,"Shfl");
Convection.c:    input_float("rayleigh",&(E->control.Ra_temp),"essential");
Convection.c:    E->data.ref_viscosity = E->data.grav_acc*E->data.density*E->data.therm_exp
Convection.c:                  *E->data.ref_temperature*E->data.layer_meter*E->data.layer_meter*E->data.layer_meter
Convection.c:                  /(E->control.Ra_temp*E->data.therm_diff);
Convection.c:    input_float("rayleigh_comp",&(E->control.Ra_comp),"essential");
Convection.c:    density_diff=E->control.Ra_comp*E->data.ref_viscosity*E->data.therm_diff/(E->data.grav_acc*E->data.layer_meter*E->data.layer_meter*E->data.layer_meter);
Convection.c:    fprintf(E->fp,"Ra_temp=%.5e Ra_comp=%.5e %.5e %.5e\n",E->control.Ra_temp,E->control.Ra_comp,E->data.ref_viscosity,density_diff);
Convection.c:    input_boolean("halfspace",&(E->convection.half_space_cooling),"off");
Convection.c:    input_float("halfspage",&(E->convection.half_space_age),"nodefault");
Convection.c:    input_int("temperature_blobs",&(E->convection.temp_blobs),"0");
Convection.c:    input_float_vector("temperature_blobx",E->convection.temp_blobs,E->convection.temp_blob_x);
Convection.c:    input_float_vector("temperature_bloby",E->convection.temp_blobs,E->convection.temp_blob_y);
Convection.c:    input_float_vector("temperature_blobz",E->convection.temp_blobs,E->convection.temp_blob_z);
Convection.c:    input_float_vector("temperature_blobsize",E->convection.temp_blobs,E->convection.temp_blob_radius);
Convection.c:    input_float_vector("temperature_blobDT",E->convection.temp_blobs,E->convection.temp_blob_T);
Convection.c:    input_float_vector("temperature_blobbg",E->convection.temp_blobs,E->convection.temp_blob_bg);
Convection.c:    input_int_vector("temperature_blobsticky",E->convection.temp_blobs,E->convection.temp_blob_sticky);
Convection.c:    input_int("temperature_zones",&(E->convection.temp_zones),"0");
Convection.c:    input_float_vector("temperature_zonex1",E->convection.temp_zones,E->convection.temp_zonex1);
Convection.c:    input_float_vector("temperature_zonex2",E->convection.temp_zones,E->convection.temp_zonex2);
Convection.c:    input_float_vector("temperature_zonez1",E->convection.temp_zones,E->convection.temp_zonez1);
Convection.c:    input_float_vector("temperature_zonez2",E->convection.temp_zones,E->convection.temp_zonez2);
Convection.c:    input_float_vector("temperature_zoney1",E->convection.temp_zones,E->convection.temp_zoney1);
Convection.c:    input_float_vector("temperature_zoney2",E->convection.temp_zones,E->convection.temp_zoney2);
Convection.c:    input_float_vector("temperature_zoney2",E->convection.temp_zones,E->convection.temp_zoney2);
Convection.c:    input_float_vector("temperature_zoney2",E->convection.temp_zones,E->convection.temp_zoney2);
Convection.c:    input_float_vector("temperature_zonehw",E->convection.temp_zones,E->convection.temp_zonehw);
Convection.c:    input_float_vector("temperature_zonemag",E->convection.temp_zones,E->convection.temp_zonemag);
Convection.c:    input_int_vector("temperature_zonesticky",E->convection.temp_zones,E->convection.temp_zone_sticky);
Convection.c:    input_int("num_perturbations",&(E->convection.number_of_perturbations),"0,0,32");
Convection.c:    input_float_vector("perturbmag",E->convection.number_of_perturbations,E->convection.perturb_mag);
Convection.c:    input_float_vector("perturbk",E->convection.number_of_perturbations,E->convection.perturb_k);
Convection.c:    input_string("prevT",E->convection.old_T_file,"initialize");
Convection.c:    if (E->control.restart)    {
Convection.c:       input_int("restart_timesteps",&(E->monitor.solution_cycles),"0");
Convection.c:       input_string("oldfile",E->convection.old_T_file,"initialize");
Convection.c:    const int dims=E->mesh.nsd;
Convection.c:    noy=E->mesh.noy;  
Convection.c:    noz=E->mesh.noz;  
Convection.c:    nox=E->mesh.nox;  
Convection.c:    para1 = E->control.Ts*E->data.ref_temperature + 0.4*E->data.ref_temperature; 
Convection.c:    tbase = (para1 - E->control.Ts*E->data.ref_temperature)/E->data.ref_temperature;
Convection.c:    tbase1 = (para1 + 200 - E->control.Ts*E->data.ref_temperature)/E->data.ref_temperature;
Convection.c:    mm = E->convection.perturb_k[0];
Convection.c:    con = E->convection.perturb_mag[0];
Convection.c:  if (E->control.restart==0 )    {
Convection.c:                t1=E->X[1][node];
Convection.c:                r1=E->X[2][node];
Convection.c:                E->T[node] = 0.0;
Convection.c:                E->C[node] = 0.0;
Convection.c:                Ti=E->control.inter_temp;
Convection.c:                E->T[node] = 1-r1 +
Convection.c:                if (E->control.continent_lith) {
Convection.c:                    if(t1>=E->control.continent_loc_left&&t1<=E->control.continent_loc_right){
Convection.c:                        E->T[node]=Ti;
Convection.c:                        if(r1>=E->control.depth_continent_lith){
Convection.c:                            E->T[node]=Ti*(1.0-r1)/E->control.depth_continent_lith;
Convection.c:                if (E->control.ocean_lith) {
Convection.c:                    if(t1>=E->control.age_loc_left&&t1<=E->control.age_loc_right){
Convection.c:                        E->T[node]=Ti;
Convection.c:                        if(r1>=E->control.depth_ocean_lith){
Convection.c:                            age_x = E->control.age_left+(t1-E->control.age_loc_left)/(E->control.age_loc_right-E->control.age_loc_left)*(E->control.age_right-E->control.age_left);
Convection.c:                            tempt=(1.0-r1)*0.5/sqrt(age_x)*E->data.layer_km*1.0e3/sqrt(365*24*3600*1e6*E->data.therm_diff);
Convection.c:                            E->T[node]=Ti*erf(tempt);
Convection.c:                            if(E->control.platemodel) {
Convection.c:                                temp1=(1.0-r1)/E->control.depth_ocean_lith;
Convection.c:                                temp2=365*24*3600*1e6*E->data.therm_diff*age_x;
Convection.c:                                temp3=temp2/(E->control.depth_ocean_lith*E->data.layer_km*1.0e3*E->control.depth_ocean_lith*E->data.layer_km*1.0e3);
Convection.c:                                E->T[node]=Ti*(temp1+2.0/M_PI*exp(-M_PI*M_PI*temp3)*sin(M_PI*temp1)+1.0/M_PI*exp(-4.0*M_PI*M_PI*temp3)*sin(2.0*M_PI*temp1)+2.0/3.0/M_PI*exp(-9.0*M_PI*M_PI*temp3)*sin(3.0*M_PI*temp1)+2.0/4.0/M_PI*exp(-16.0*M_PI*M_PI*temp3)*sin(4.0*M_PI*temp1));
Convection.c:                                if(E->T[node]>Ti)
Convection.c:                                    E->T[node]=Ti;
Convection.c:                    if(E->control.ocean_lith_margin){
Convection.c:                        tempdist = (t1-E->control.age_loc_left)*tan(E->control.dip_margin*3.14159265/180.0) + 1.0-r1;
Convection.c:                        if(tempdist>=0&&tempdist<=1.0-E->control.depth_ocean_lith&&r1>=E->control.depth_lith_margin&&t1<E->control.age_loc_left){
Convection.c:                            age_x = E->control.age_left;
Convection.c:                            tempt=tempdist*0.5/sqrt(age_x)*E->data.layer_km*1.0e3/sqrt(365*24*3600*1e6*E->data.therm_diff);
Convection.c:                            E->T[node]=Ti*erf(tempt);
Convection.c:                            if(E->control.platemodel) {
Convection.c:                                temp1=tempdist/E->control.depth_ocean_lith;
Convection.c:                                temp2=365*24*3600*1e6*E->data.therm_diff*age_x;
Convection.c:                                temp3=temp2/(E->control.depth_ocean_lith*E->data.layer_km*1.0e3*E->control.depth_ocean_lith*E->data.layer_km*1.0e3);
Convection.c:                                E->T[node]=Ti*(temp1+2.0/M_PI*exp(-M_PI*M_PI*temp3)*sin(M_PI*temp1)+1.0/M_PI*exp(-4.0*M_PI*M_PI*temp3)*sin(2.0*M_PI*temp1)+2.0/3.0/M_PI*exp(-9.0*M_PI*M_PI*temp3)*sin(3.0*M_PI*temp1)+2.0/4.0/M_PI*exp(-16.0*M_PI*M_PI*temp3)*sin(4.0*M_PI*temp1));
Convection.c:                                if(E->T[node]>Ti)
Convection.c:                                    E->T[node]=Ti;
Convection.c:                        else if(tempdist>1.0-E->control.depth_ocean_lith&&r1>=E->control.depth_lith_margin&&t1<E->control.age_loc_left){
Convection.c:                            E->T[node]=Ti;
Convection.c:              E->C[node] = 0.0;
Convection.c:              E->node[node] = E->node[node] | (INTX | INTZ | INTY);
Convection.c:      if (E->control.composition) {
Convection.c:         if (!(strcmp(E->control.comp_adv_method,"field")==0)) {
Convection.c:            if(E->control.composition_phasechange) {
Convection.c:         else if ((strcmp(E->control.comp_adv_method,"field")==0))  {
Convection.c:            for(node=1;node<=E->mesh.nno;node++)  {
Convection.c:                  t1=E->X[1][node];
Convection.c:                  r1=E->X[2][node];
Convection.c:                  if (r1>=1.0-E->viscosity.zcrust1)
Convection.c:                     E->C[node] = 1.0;
Convection.c:                     E->C[node] = 0.0;
Convection.c:   else if (E->control.restart==1)  {
Convection.c:      process_restart_tc(E,E->mesh.levmax);
Convection.c:      if (E->control.composition && !(strcmp(E->control.comp_adv_method,"field")==0))
Convection.c:    E->advection.markers = E->advection.markers_per_ele*E->mesh.nel;
Convection.c:    for (node=1;node<=E->advection.markers;node++)  {
Convection.c:      E->XMC[1][node] = drand48()*(E->X[1][E->mesh.nno]-E->X[1][1]);
Convection.c:      E->XMC[2][node] = drand48()*(E->X[2][E->mesh.nno]-E->X[2][1]);
Convection.c:      el = get_element(E,E->XMC[1][node],E->XMC[2][node],dX);
Convection.c:      E->CElement[node] = el;
Convection.c://      if (E->XMC[2][node]>E->viscosity.zcrust1)
Convection.c:        if (E->XMC[2][node]>(E->viscosity.zcrust1+0.02*cos(M_PI*E->XMC[1][node]/E->X[1][E->mesh.nno])))
Convection.c:              E->C12[node] = 0;
Convection.c:              E->C12[node] = 1;
Convection.c:    get_C_from_markers(E,E->C,E->CElement);
Convection.c:    p = pow((double)E->advection.markers_per_ele,(double)(1.0/E->mesh.dof));
Convection.c:    for (el=1;el<=E->mesh.nel;el++)  {
Convection.c:      dx = (E->X[1][E->ien[el].node[3]] - E->X[1][E->ien[el].node[1]])/p;
Convection.c:      dr = (E->X[2][E->ien[el].node[3]] - E->X[2][E->ien[el].node[1]])/p;
Convection.c:        E->XMC[1][node] = E->X[1][E->ien[el].node[1]] + dx*(i-0.5);
Convection.c:        E->XMC[2][node] = E->X[2][E->ien[el].node[1]] + dr*(j-0.5);
Convection.c:        E->CElement[node] = el;
Convection.c://        if (E->XMC[2][node]>E->viscosity.zcrust1)
Convection.c:        if (E->XMC[2][node]>(E->viscosity.zcrust1+0.02*cos(M_PI*E->XMC[1][node]/E->X[1][E->mesh.nno])))
Convection.c:              E->C12[node] = 0;
Convection.c:              E->C12[node] = 1;
Convection.c:    E->advection.markers = node;
Convection.c:    get_C_from_markers(E,E->C,E->CElement);
Convection.c:    p = pow((double)E->advection.markers_per_ele,(double)(1.0/E->mesh.dof));
Convection.c:    for (el=1;el<=E->mesh.nel;el++)  {
Convection.c:      dx = (E->X[1][E->ien[el].node[3]] - E->X[1][E->ien[el].node[1]])/p;
Convection.c:      dr = (E->X[2][E->ien[el].node[3]] - E->X[2][E->ien[el].node[1]])/p;
Convection.c:        E->XMC[1][node] = E->X[1][E->ien[el].node[1]] + dx*(i-0.5);
Convection.c:        E->XMC[2][node] = E->X[2][E->ien[el].node[1]] + dr*(j-0.5);
Convection.c:        E->CElement[node] = el;
Convection.c:        if (E->XMC[2][node]<1.0-E->viscosity.zcrust1)
Convection.c:              E->C12[node] = 0;
Convection.c:              E->C12[node] = 1;
Convection.c:    E->advection.markers = node;
Convection.c:    get_C_from_markers(E,E->C,E->CElement);
Convection.c:    p = pow((double)E->advection.markers_per_ele,(double)(1.0/E->mesh.dof));
Convection.c:    for (el=1;el<=E->mesh.nel;el++)  {
Convection.c:      dx = (E->X[1][E->ien[el].node[3]] - E->X[1][E->ien[el].node[1]])/p;
Convection.c:      dr = (E->X[2][E->ien[el].node[3]] - E->X[2][E->ien[el].node[1]])/p;
Convection.c:        E->XMC[1][node] = E->X[1][E->ien[el].node[1]] + dx*(i-0.5);
Convection.c:        E->XMC[2][node] = E->X[2][E->ien[el].node[1]] + dr*(j-0.5);
Convection.c:        E->CElement[node] = el;
Convection.c:        if (E->XMC[2][node]<E->viscosity.zlm)
Convection.c:              E->C12[node] = 1;
Convection.c:              E->C12[node] = 0;
Convection.c:    E->advection.markers = node;
Convection.c:    get_C_from_markers(E,E->C,E->CElement);
Convection.c: sprintf(output_file,"%s/temp_comp.%d",E->convection.old_T_file,E->monitor.solution_cycles);
Convection.c:   sscanf(input_s,"%d %d %g",&i,&E->advection.timesteps,&E->monitor.elapsed_time);
Convection.c: if (E->control.composition)   {
Convection.c:   for (i=1;i<=E->mesh.NNO[lev];i++)   {
Convection.c:     sscanf(input_s,"%g %g %g %g",&E->T[i],&E->C[i],&t1,&t2);
Convection.c:     E->U[E->id[i].doff[1]]=t1;
Convection.c:     E->U[E->id[i].doff[2]]=t2;
Convection.c:   for (i=1;i<=E->mesh.NEL[lev];i++)   {
Convection.c:     E->P[i] = t1;
Convection.c:   for (i=1;i<=E->mesh.NNO[lev];i++)   {
Convection.c:     sscanf(input_s,"%g %g %g",&E->T[i],&t1,&t2);
Convection.c:     E->U[E->id[i].doff[1]]=t1;
Convection.c:     E->U[E->id[i].doff[2]]=t2;
Convection.c:     E->C[i]=0;
Convection.c:   for (i=1;i<=E->mesh.NEL[lev];i++)   {
Convection.c:     E->P[i] = t1;
Convection.c: E->advection.timesteps = E->monitor.solution_cycles;
Convection.c: sprintf(output_file,"%s/traces.%d",E->convection.old_T_file,E->monitor.solution_cycles);
Convection.c:   sscanf(input_s,"%d %d %g",&E->advection.markers,&E->advection.timesteps,&E->monitor.elapsed_time);
Convection.c:   for (i=1;i<=E->advection.markers;i++)  {
Convection.c:      sscanf(input_s,"%g %g %d %d",&E->XMC[1][i],&E->XMC[2][i],&E->CElement[i],&E->C12[i]);
Convection.c:   for (i=1;i<=E->mesh.nel;i++)  {
Convection.c:      sscanf(input_s,"%g",&E->CE[i]);
Convection.c: E->advection.timesteps = E->monitor.solution_cycles;
Convection.c: get_C_from_markers(E,E->C,E->CElement);
Drive_solvers.c:    const int nno = E->mesh.nno;
Drive_solvers.c:    const int nel = E->mesh.nel;
Drive_solvers.c:    const int nnov = E->mesh.nnov;
Drive_solvers.c:    const int neq = E->mesh.neq;
Drive_solvers.c:    const int vpts = vpoints[E->mesh.nsd];
Drive_solvers.c:    const int dims = E->mesh.nsd;
Drive_solvers.c:    E->monitor.elapsed_time_vsoln1 =  E->monitor.elapsed_time_vsoln;
Drive_solvers.c:    E->monitor.elapsed_time_vsoln = E->monitor.elapsed_time;
Drive_solvers.c:    velocities_conform_bcs(E,E->U);
Drive_solvers.c:      if(E->viscosity.update_allowed)
Drive_solvers.c:          get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:      Udot_mag = kineticE(E,E->U,E->mesh.levmax);
Drive_solvers.c:      fprintf(E->fp,"%g %.6e \n",E->monitor.elapsed_time,Udot_mag);
Drive_solvers.c:      fflush(E->fp);
Drive_solvers.c:      fprintf(stderr,"kinetic energy= %.7e at time= %g for step %d\n",Udot_mag,E->monitor.elapsed_time,E->monitor.solution_cycles);
Drive_solvers.c:      if (  E->viscosity.SDEPV  )   {
Drive_solvers.c:          delta_U[i] = E->U[i] - oldU[i]; 
Drive_solvers.c:          oldU[i] = E->U[i];
Drive_solvers.c:        Udot_mag  = sqrt(fvdot(E,oldU,oldU,E->mesh.levmax));
Drive_solvers.c:        dUdot_mag = vnorm_nonnewt(E,delta_U,oldU,E->mesh.levmax); 
Drive_solvers.c:          fprintf(E->fp,"Stress dependent viscosity: DUdot = %.4e (%.4e) for iteration %d\n",dUdot_mag,Udot_mag,count);
Drive_solvers.c:          fflush(E->fp); 
Drive_solvers.c:      } while((count < 50) && (dUdot_mag>E->viscosity.sdepv_misfit) && E->viscosity.SDEPV);
Drive_solvers.c:          fflush(E->fp); 
Element_calculations.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:  const int neq=E->mesh.neq;
Element_calculations.c:  const int npno=E->mesh.npno;
Element_calculations.c:  const int nel=E->mesh.nel;
Element_calculations.c:  const int lev=E->mesh.levmax;
Element_calculations.c:    E->F[a] = 0.0;
Element_calculations.c:    E->H[a]=0.0;*/
Element_calculations.c:	    E->H[e] = elt_h[0];  /* due to single pressure node per element */
Element_calculations.c:       a1=E->lm[e].node[a].doff[1];
Element_calculations.c:       E->F[a1] += elt_f[p];
Element_calculations.c:       a2=E->lm[e].node[a].doff[2];
Element_calculations.c:       E->F[a2] += elt_f[p+1];
Element_calculations.c:         a3=E->lm[e].node[a].doff[3];
Element_calculations.c:         E->F[a3] += elt_f[p+2];
Element_calculations.c:   strip_bcs_from_residual(E,E->F,lev);
Element_calculations.c:    const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:    const int vpts=vpoints[E->mesh.nsd];
Element_calculations.c:    const int ppts=ppoints[E->mesh.nsd];
Element_calculations.c:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:	W[nint] = g_point[nint].weight[dims-1] * dOmega.vpt[nint] * E->EVI[level][(el-1)*vpts+nint];
Element_calculations.c:  if(E->control.NMULTIGRID||E->control.NASSEMBLE)
Element_calculations.c:  const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:  const int ends=enodes[E->mesh.nsd]; 
Element_calculations.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof; 
Element_calculations.c:  const int nel=E->mesh.NEL[level];
Element_calculations.c:  const int neq=E->mesh.NEQ[level];
Element_calculations.c:	a1 = E->LMD[level][e].node[a].doff[1];   
Element_calculations.c:	a2 = E->LMD[level][e].node[a].doff[2];   
Element_calculations.c:	if(dims ==3 ) a3 = E->LMD[level][e].node[a].doff[3];   
Element_calculations.c:	                E->elt_k[level][e].k[ii  ] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[1]] 
Element_calculations.c:	              + E->elt_k[level][e].k[ii+1] *
Element_calculations.c:		        u[E->LMD[level][e].node[b].doff[2]]; 
Element_calculations.c:		        E->elt_k[level][e].k[ii+n  ] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[1]] 
Element_calculations.c:		      + E->elt_k[level][e].k[ii+n+1] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[2]]; 
Element_calculations.c:		        E->elt_k[level][e].k[ii] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[1]]   
Element_calculations.c:		      + E->elt_k[level][e].k[ii+1] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[2]]   
Element_calculations.c:		      + E->elt_k[level][e].k[ii+2] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[3]]; 
Element_calculations.c:		        E->elt_k[level][e].k[ii+n] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[1]] 
Element_calculations.c:		      + E->elt_k[level][e].k[ii+n+1] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[2]]   
Element_calculations.c:		      + E->elt_k[level][e].k[ii+n+2] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[3]]; 
Element_calculations.c:		        E->elt_k[level][e].k[ii+n+n] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[1]] 
Element_calculations.c:		      + E->elt_k[level][e].k[ii+n+n+1] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[2]]   
Element_calculations.c:		      + E->elt_k[level][e].k[ii+n+n+2] * 
Element_calculations.c:			u[E->LMD[level][e].node[b].doff[3]]; 
Element_calculations.c:    const int neq=E->mesh.NEQ[level];
Element_calculations.c:    const int nno=E->mesh.NNO[level];
Element_calculations.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:	    if(E->NODE[level][e] & OFFSIDE) 
Element_calculations.c:	     eqn1=E->ID[level][e].doff[1];
Element_calculations.c:	     eqn2=E->ID[level][e].doff[2];
Element_calculations.c:	     eqn3=E->ID[level][e].doff[3];
Element_calculations.c:	     max_eqn = E->Node_eqn[level][e+1]-E->Node_eqn[level][e];
Element_calculations.c:	     C=E->Node_map[level] + E->Node_eqn[level][e];
Element_calculations.c:	     B1=E->Eqn_k[level]+E->Node_k_id[level][e];
Element_calculations.c:	     B2=E->Eqn_k[level]+E->Node_k_id[level][e]+max_eqn;
Element_calculations.c:	     B3=E->Eqn_k[level]+E->Node_k_id[level][e]+2*max_eqn;
Element_calculations.c:	    if(E->NODE[level][e] & OFFSIDE) 
Element_calculations.c:	    eqn1=E->ID[level][e].doff[1];
Element_calculations.c:	    eqn2=E->ID[level][e].doff[2];
Element_calculations.c:	    max_eqn = E->Node_eqn[level][e+1]-E->Node_eqn[level][e];
Element_calculations.c:	    C=E->Node_map[level] + E->Node_eqn[level][e];
Element_calculations.c:	    B1=E->Eqn_k[level]+E->Node_k_id[level][e];
Element_calculations.c:	    B2=E->Eqn_k[level]+E->Node_k_id[level][e]+max_eqn;
Element_calculations.c:    const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:    const int dims=E->mesh.nsd;
Element_calculations.c:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:	    a1 = E->LMD[level][el].node[a].doff[1];
Element_calculations.c:	    E->BI[level][a1] += elt_k[p*n+p];  
Element_calculations.c:	    a2 = E->LMD[level][el].node[a].doff[2];
Element_calculations.c:	    E->BI[level][a2] += elt_k[p*n+p];  
Element_calculations.c:	        a1 = E->LMD[level][el].node[a].doff[3];
Element_calculations.c:	        E->BI[level][a1] += elt_k[p*n+p];  
Element_calculations.c:    npno = E->mesh.NPNO[level];
Element_calculations.c:    neq=E->mesh.NEQ[level];
Element_calculations.c:	E->BPI[level][e]=1.0;
Element_calculations.c:    if(!E->control.precondition)
Element_calculations.c:	    E->BPI[level][e] = 1.0/BU;
Element_calculations.c:	    E->BPI[level][e] = 1.0;
Element_calculations.c:    const int nel=E->mesh.NEL[level];
Element_calculations.c:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:    const int npno=E->mesh.NPNO[level];
Element_calculations.c:	    j1= E->LMD[level][e].node[a].doff[1];
Element_calculations.c:	    j2= E->LMD[level][e].node[a].doff[2];
Element_calculations.c:	    j3= E->LMD[level][e].node[a].doff[3];
Element_calculations.c:	    /* for(b=0;b<ploc_mat_size[E->mesh.nsd];b++) */
Element_calculations.c:	    divU[e] += E->elt_del[level][e].g[p  ][0] * U[j1]
Element_calculations.c:	             + E->elt_del[level][e].g[p+1][0] * U[j2]
Element_calculations.c:	             + E->elt_del[level][e].g[p+2][0] * U[j3];
Element_calculations.c:	    j1= E->LMD[level][e].node[a].doff[1];
Element_calculations.c:	    j2= E->LMD[level][e].node[a].doff[2];
Element_calculations.c:	    /* for(b=0;b<ploc_mat_size[E->mesh.nsd];b++) */
Element_calculations.c:	    divU[e] += E->elt_del[level][e].g[p  ][0] * U[j1]
Element_calculations.c:	             + E->elt_del[level][e].g[p+1][0] * U[j2];
Element_calculations.c:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:  nel=E->mesh.NEL[lev];
Element_calculations.c:  neq=E->mesh.NEQ[lev];
Element_calculations.c:             j1=E->LMD[lev][e].node[a].doff[1];
Element_calculations.c:             j2=E->LMD[lev][e].node[a].doff[2];
Element_calculations.c:		        /*for(b=0;b<ploc_mat_size[E->mesh.nsd];b++)  */ 
Element_calculations.c:             gradP[j1] += E->elt_del[lev][e].g[p][0] * P[e];
Element_calculations.c:             gradP[j2] += E->elt_del[lev][e].g[p+1][0] * P[e];
Element_calculations.c:               j1=E->LMD[lev][e].node[a].doff[3];
Element_calculations.c:               gradP[j1] += E->elt_del[lev][e].g[p+2][0] * P[e];
Element_calculations.c:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:    npno=E->mesh.NPNO[level];
Element_calculations.c:      j=E->LMD[level][e].node[a].doff[1];
Element_calculations.c:      gradP[p] += E->BI[level][j]*E->elt_del[level][e].g[p][0];
Element_calculations.c:      j=E->LMD[level][e].node[a].doff[2];
Element_calculations.c:      gradP[p+1] += E->BI[level][j]*E->elt_del[level][e].g[p+1][0];
Element_calculations.c:        j=E->LMD[level][e].node[a].doff[3];
Element_calculations.c:        gradP[p+2] += E->BI[level][j]*E->elt_del[level][e].g[p+2][0];
Element_calculations.c:      divU +=E->elt_del[level][e].g[p][0] * gradP[p];	    
Element_calculations.c:      divU +=E->elt_del[level][e].g[p+1][0] * gradP[p+1];
Element_calculations.c:        divU +=E->elt_del[level][e].g[p+2][0] * gradP[p+2];
Element_calculations.c:   const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:  for(i=1;i<=E->mesh.nsd;i++)
Element_calculations.c:    { for(a=1;a<=enodes[E->mesh.nsd];a++)
Element_calculations.c:	{ if (E->node[E->ien[el].node[a]] & type)
Element_calculations.c:		{  get_elt_g(E,el,elt_g,E->mesh.levmax);
Element_calculations.c:	      p=E->mesh.nsd*(a-1) + i - 1;
Element_calculations.c:	      for(b=1;b<=pnodes[E->mesh.nsd];b++)
Element_calculations.c:		  elt_h[q] -= elt_g[p][q] * E->VB[i][E->ien[el].node[a]];
Element_calculations.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:  get_global_shape_fn(E,el,&GN,&GNx,&dOmega,0,E->mesh.levmax);
Element_calculations.c:	    force[p] = E->buoyancy[E->ien[el].node[p]];
Element_calculations.c:	  nodea=E->ien[el].node[a];
Element_calculations.c:		     force_at_gs[j] += force[k] * E->N.vpt[GNVINDEX(k,j)] ;
Element_calculations.c:		 elt_f[p] += force_at_gs[j] * E->N.vpt[GNVINDEX(a,j)]
Element_calculations.c:		      nodeb=E->ien[el].node[b];
Element_calculations.c:		      if ((E->node[nodeb] & type) && (E->VB[j][nodeb] != 0.0)){
Element_calculations.c:			      get_elt_k(E,el,elt_k,E->mesh.levmax,penalty);
Element_calculations.c:			      elt_f[p] -= elt_k[p*n+q] * E->VB[j][nodeb];
Element_calculations.c:/* printf("el %d: dirn=%d, vbc found at node %d of %g\n",el,j,b,E->VB[j][nodeb]);*/
Element_calculations.c:     const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:     const int ends=enodes[E->mesh.nsd];
Element_calculations.c:     const int vpts=vpoints[E->mesh.nsd];
Element_calculations.c:     const int dims=E->mesh.nsd;
Element_calculations.c:	  Visc += E->EVI[level][(el-1)*vpts+a];
Element_calculations.c:        nodea=E->IEN[level][el].node[a];
Element_calculations.c:           nodeb=E->IEN[level][el].node[b];      /* for Kab dims*dims  */
Element_calculations.c:	   elt_k[i  ] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][el].g[p[a]][0]*
Element_calculations.c:		      E->elt_del[level][el].g[p[b]][0];   /*for 11 */
Element_calculations.c:	   elt_k[i+1] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][el].g[p[a]][0]*
Element_calculations.c:		      E->elt_del[level][el].g[p[b]+1][0];  /* for 12 */
Element_calculations.c:	   elt_k[i+n] += Visc*E->control.augmented*          
Element_calculations.c:	              E->elt_del[level][el].g[p[a]+1][0]*
Element_calculations.c:		      E->elt_del[level][el].g[p[b]][0];    /* for 21 */
Element_calculations.c:	   elt_k[i+n+1] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][el].g[p[a]+1][0]*
Element_calculations.c:		      E->elt_del[level][el].g[p[b]+1][0];  /* for 22 */
Element_calculations.c:	       elt_k[i+2] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][el].g[p[a]][0]*
Element_calculations.c:		      E->elt_del[level][el].g[p[b]+2][0];  /* for 13 */
Element_calculations.c:	       elt_k[i+n+2] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][el].g[p[a]+1][0]*
Element_calculations.c:		      E->elt_del[level][el].g[p[b]+2][0];  /* for 23 */
Element_calculations.c:	       elt_k[i+n+n] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][el].g[p[a]+2][0]*
Element_calculations.c:		      E->elt_del[level][el].g[p[b]][0];    /* for 31 */
Element_calculations.c:	       elt_k[i+n+n+1] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][el].g[p[a]+2][0]*
Element_calculations.c:		      E->elt_del[level][el].g[p[b]+1][0];  /* for 32 */
Element_calculations.c:	       elt_k[i+n+n+2] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][el].g[p[a]+2][0]*
Element_calculations.c:		      E->elt_del[level][el].g[p[b]+2][0];  /* for 33 */
General_matrix_functions.c:    const int n=E->mesh.NPNO[lev];
General_matrix_functions.c:    const int n=E->mesh.npno;
General_matrix_functions.c:    const int n = E->mesh.NEQ[level];
General_matrix_functions.c:    const int n = E->mesh.NEQ[level];
General_matrix_functions.c:  n = E->mesh.NEQ[level];
General_matrix_functions.c:  n = E->mesh.NEQ[level];
General_matrix_functions.c:    for(e=1;e<=E->mesh.nel;e++)
General_matrix_functions.c:      for(i=1;i<=vpoints[E->mesh.nsd];i++)
General_matrix_functions.c:	{ j=E->ien[e].node[i];
General_matrix_functions.c:	  domega =  E->ECO[E->mesh.levmax][e].area;
General_matrix_functions.c:    for(e=1;e<=E->mesh.nel;e++)
General_matrix_functions.c:      for(i=1;i<=vpoints[E->mesh.nsd];i++)
General_matrix_functions.c:	{ j=E->ien[e].node[i];
General_matrix_functions.c:	  domega =  E->ECO[E->mesh.levmax][e].area;
General_matrix_functions.c:    neq  = E->mesh.NEQ[high_lev];
General_matrix_functions.c:    gneq  = E->mesh.NEQ[high_lev];
General_matrix_functions.c:	E->control.total_iteration_cycles = 0;
General_matrix_functions.c:	E->control.total_v_solver_calls = 0;
General_matrix_functions.c:	for(i=E->mesh.levmin;i<=E->mesh.levmax;i++) {
General_matrix_functions.c:    acc = max(acc,r0*E->control.accuracy);
General_matrix_functions.c:    if (!(E->control.NMULTIGRID || E->control.EMULTIGRID)) {
General_matrix_functions.c:	    cycles = E->control.v_steps_low;
General_matrix_functions.c:        fprintf(E->fp,"resi = %.6e for iter %d acc %.6e\n",residual,count,acc);
General_matrix_functions.c:/*            fprintf(E->fp,"resi = %.6e for iter %d acc %.6e\n",residual,count,acc); */
General_matrix_functions.c:/*            } while (residual > acc && count<E->control.max_vel_iterations);
General_matrix_functions.c:    if(E->control.print_convergence)   {
General_matrix_functions.c:	fprintf(E->fp,"%s residual (%03d)(%03d) = %.3e from %.3e to %.3e in %5.2f secs \n",
General_matrix_functions.c:		fflush(E->fp);
General_matrix_functions.c:    if(E->control.verbose)  {
General_matrix_functions.c:	for(i=E->mesh.levmax;i>=E->mesh.levmin;i--) {
General_matrix_functions.c:	printf("projection time = %g\n",E->monitor.cpu_time_on_mg_maps);
General_matrix_functions.c:    E->control.total_iteration_cycles += count;
General_matrix_functions.c:    E->control.total_v_solver_calls += 1;
General_matrix_functions.c:    const int levmin = E->mesh.levmin; 
General_matrix_functions.c:    const int levmax = E->mesh.levmax; 
General_matrix_functions.c:	for(i=E->mesh.levmin;i<=E->mesh.levmax;i++) { 
General_matrix_functions.c:	    vel[i] = (double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:	    res[i] = (double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:	    rhs[i] = (double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:	    fl [i] = (double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:	    del_vel[i]=(double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:	    AU[i] = (double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:    Vnmax = E->control.mg_cycle;
General_matrix_functions.c:    for(j=0;j<E->mesh.NEQ[levmax];j++)
General_matrix_functions.c:    cycles = E->control.v_steps_low;
General_matrix_functions.c:      for(j=0;j<E->mesh.NEQ[lev];j++)
General_matrix_functions.c:            cycles=((dlev==levmax)?E->control.v_steps_high:E->control.down_heavy); 
General_matrix_functions.c:	    for(i=0;i<E->mesh.NEQ[dlev];i++)
General_matrix_functions.c:       cycles = E->control.v_steps_low;
General_matrix_functions.c:            cycles=((ulev==levmax)?E->control.v_steps_high:E->control.up_heavy);
General_matrix_functions.c:	    for(i=0;i<E->mesh.NEQ[ulev];i++)
General_matrix_functions.c:                for(i=0;i<E->mesh.NEQ[ulev];i++)   {
General_matrix_functions.c:    for(j=0;j<E->mesh.NEQ[levmax];j++)   {
General_matrix_functions.c:    residual = sqrt(vselfdot(E,F,levmax)/E->mesh.NEQ[levmax]);
General_matrix_functions.c:    const int mem_lev=E->mesh.levmax;
General_matrix_functions.c:    const int high_neq = E->mesh.NEQ[level];
General_matrix_functions.c:	r0 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:	r1 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:	r2 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:	z0 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:	z1 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:	p1 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:	p2 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:	Ap = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:    residual = sqrt(vdot(E,r1,r1,level)/E->mesh.NEQ[level]);
General_matrix_functions.c:	    z1[i] = E->BI[level][i] * r1[i];
General_matrix_functions.c:	residual = sqrt(vdot(E,r2,r2,level)/E->mesh.NEQ[level]);  
General_matrix_functions.c:    const int neq=E->mesh.NEQ[level];
General_matrix_functions.c:	r1 = dvector(0,E->mesh.neq);
General_matrix_functions.c:	x1 = dvector(0,E->mesh.neq);
General_matrix_functions.c:	    x1[i] = r1[i] * E->BI[level][i];
General_matrix_functions.c:    const int dims=E->mesh.nsd;
General_matrix_functions.c:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:    const int neq=E->mesh.NEQ[level];
General_matrix_functions.c:    const int nel=E->mesh.NEL[level];
General_matrix_functions.c:    const int nno=E->mesh.NNO[level];
General_matrix_functions.c:	    elt_k = E->elt_k[level][e].k;
General_matrix_functions.c:		node=E->IEN[level][e].node[i];
General_matrix_functions.c:		if(E->NODE[level][node] & VBX)
General_matrix_functions.c:		if(E->NODE[level][node] & VBZ)
General_matrix_functions.c:		if((3==dims) && (E->NODE[level][node] & VBY))
General_matrix_functions.c:		node=E->IEN[level][e].node[i];
General_matrix_functions.c:		eqn1=E->ID[level][node].doff[1];
General_matrix_functions.c:		eqn2=E->ID[level][node].doff[2];
General_matrix_functions.c:		    eqn3=E->ID[level][node].doff[3];
General_matrix_functions.c:		    node1=E->IEN[level][e].node[j];
General_matrix_functions.c:			eqn11=E->ID[level][node1].doff[1];
General_matrix_functions.c:			eqn12=E->ID[level][node1].doff[2];
General_matrix_functions.c:		   	eqn13=E->ID[level][node1].doff[3];
General_matrix_functions.c:			eqn11=E->ID[level][node1].doff[1];
General_matrix_functions.c:			eqn12=E->ID[level][node1].doff[2];
General_matrix_functions.c:		node=E->IEN[level][e].node[i];
General_matrix_functions.c:		eqn1=E->ID[level][node].doff[1];
General_matrix_functions.c:		eqn2=E->ID[level][node].doff[2];
General_matrix_functions.c:		    eqn3=E->ID[level][node].doff[3];
General_matrix_functions.c:		d0[eqn1] += (dd[eqn1] = w[(i-1)*dims]*(F[eqn1]-Ad[eqn1])*E->BI[level][eqn1]); 
General_matrix_functions.c:		d0[eqn2] += (dd[eqn2] = w[(i-1)*dims+1]*(F[eqn2]-Ad[eqn2])*E->BI[level][eqn2]); 
General_matrix_functions.c:		    d0[eqn3] += (dd[eqn3] = w[(i-1)*dims+2]*(F[eqn3]-Ad[eqn3])*E->BI[level][eqn3]); 
General_matrix_functions.c:		   node1=E->IEN[level][e].node[j];
General_matrix_functions.c:		       eqn11=E->ID[level][node1].doff[1];
General_matrix_functions.c:		       eqn12=E->ID[level][node1].doff[2];
General_matrix_functions.c:		       eqn13=E->ID[level][node1].doff[3];
General_matrix_functions.c:		       eqn11=E->ID[level][node1].doff[1];
General_matrix_functions.c:		       eqn12=E->ID[level][node1].doff[2];
General_matrix_functions.c:    const int dims=E->mesh.nsd;
General_matrix_functions.c:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:    const int neq=E->mesh.NEQ[level];
General_matrix_functions.c:    const int num_nodes=E->mesh.NNO[level];
General_matrix_functions.c:    const int nox=E->mesh.NOX[level];
General_matrix_functions.c:    const int noz=E->mesh.NOY[level];
General_matrix_functions.c:    const int noy=E->mesh.NOZ[level];
General_matrix_functions.c: /* fprintf(E->fp,"in g_s level=%d\n",level);
General_matrix_functions.c:    fprintf(E->fp,"%d %g %g\n",i,F[i],E->BI[level][i]);
General_matrix_functions.c:	    if(E->NODE[level][i] & OFFSIDE) 
General_matrix_functions.c:  	    max_eqn = E->Node_eqn[level][i+1]-E->Node_eqn[level][i];
General_matrix_functions.c:            C=E->Node_map[level]+E->Node_eqn[level][i];
General_matrix_functions.c:	    B1=E->Eqn_k[level]+E->Node_k_id[level][i];
General_matrix_functions.c:	    B2=E->Eqn_k[level]+E->Node_k_id[level][i]+max_eqn;
General_matrix_functions.c:		eqn1=E->ID[level][i].doff[1];
General_matrix_functions.c:		eqn2=E->ID[level][i].doff[2];
General_matrix_functions.c:		U1 = (F[eqn1] - Ad[eqn1])*E->BI[level][eqn1]; 
General_matrix_functions.c:		U2 = (F[eqn2] - Ad[eqn2])*E->BI[level][eqn2];
General_matrix_functions.c:/*    fprintf(E->fp,"%d %d %d %g %g %g %g\n",max_eqn,eqn1,eqn2,U1,U2,Ad[eqn1],Ad[eqn2]);
General_matrix_functions.c:/*    fprintf(E->fp,"%d %d %g %g \n",j,C[j],B1[j],B2[j]);  */
General_matrix_functions.c:		eqn1=E->ID[level][i].doff[1];
General_matrix_functions.c:		eqn2=E->ID[level][i].doff[2];
General_matrix_functions.c:		eqn3=E->ID[level][i].doff[3];
General_matrix_functions.c:		B3=E->Eqn_k[level]+E->Node_k_id[level][i]+2*max_eqn;
General_matrix_functions.c:		U1 = (F[eqn1] - Ad[eqn1])*E->BI[level][eqn1]; 
General_matrix_functions.c:		U2 = (F[eqn2] - Ad[eqn2])*E->BI[level][eqn2];
General_matrix_functions.c:		U3 = (F[eqn3] - Ad[eqn3])*E->BI[level][eqn3];
General_matrix_functions.c:    const int dims=E->mesh.nsd;
General_matrix_functions.c:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:    const int neq=E->mesh.NEQ[level];
General_matrix_functions.c:    const int num_nodes=E->mesh.NNO[level];
General_matrix_functions.c:	r1=(double *)malloc((E->mesh.neq+2)*sizeof(double));
General_matrix_functions.c:		if(E->NODE[level][i] & OFFSIDE) 
General_matrix_functions.c:		eqn1=E->ID[level][i].doff[1];
General_matrix_functions.c:		eqn2=E->ID[level][i].doff[2];
General_matrix_functions.c:  	        max_eqn = E->Node_eqn[level][i+1]-E->Node_eqn[level][i];
General_matrix_functions.c:                C=E->Node_map[level]+E->Node_eqn[level][i];
General_matrix_functions.c:	        B1=E->Eqn_k[level]+E->Node_k_id[level][i];
General_matrix_functions.c:	        B2=E->Eqn_k[level]+E->Node_k_id[level][i]+max_eqn;
General_matrix_functions.c:		    eqn3=E->ID[level][i].doff[3];
General_matrix_functions.c:	            B3=E->Eqn_k[level]+E->Node_k_id[level][i]+2*max_eqn;
General_matrix_functions.c:		U1 = (F[eqn1] - Ad[eqn1]) * E->BI[level][eqn1];
General_matrix_functions.c:		U2 = (F[eqn2] - Ad[eqn2]) * E->BI[level][eqn2];
General_matrix_functions.c:		    U3 = (F[eqn3] - Ad[eqn3]) * E->BI[level][eqn3];
General_matrix_functions.c:  n = loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:  for(i=1;i<=E->mesh.nno;i++)
General_matrix_functions.c: const int dims = E->mesh.nsd;
General_matrix_functions.c: const int nel=E->mesh.nel;
General_matrix_functions.c:   if (E->mat[e]==1)
General_matrix_functions.c:         dtemp += dU[ E->LMD[lev][e].node[a].doff[i] ]*
General_matrix_functions.c:                  dU[ E->LMD[lev][e].node[a].doff[i] ];
General_matrix_functions.c:         temp +=  U[ E->LMD[lev][e].node[a].doff[i] ]*
General_matrix_functions.c:                  U[ E->LMD[lev][e].node[a].doff[i] ];
General_matrix_functions.c:    const int dims = E->mesh.nsd;
General_matrix_functions.c:    noy = E->mesh.noy;
General_matrix_functions.c:    noz = E->mesh.noz;
General_matrix_functions.c:    nox = E->mesh.nox;
General_matrix_functions.c:        for(j=1;j<=E->mesh.nox;j++)     {
General_matrix_functions.c:  const int dims = E->mesh.nsd;
General_matrix_functions.c:  sizeofH = (2*E->mesh.noz+2)*sizeof(float);
General_matrix_functions.c:  noz = E->mesh.noz;
General_matrix_functions.c:  noy = E->mesh.noy;
General_matrix_functions.c:  elz = E->mesh.elz;
General_matrix_functions.c:  ely = E->mesh.ely;
General_matrix_functions.c:  elx = E->mesh.elx;
General_matrix_functions.c:            lnode[1] = E->ien[el].node[1];
General_matrix_functions.c:            lnode[2] = E->ien[el].node[4];
General_matrix_functions.c:            lnode[4] = E->ien[el].node[5];
General_matrix_functions.c:            lnode[3] = E->ien[el].node[8];
General_matrix_functions.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
General_matrix_functions.c:          for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
General_matrix_functions.c:              temp[i] += X[lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
General_matrix_functions.c:              temp[i+noz] += E->M.vpt[GMVINDEX(d,nint)]
General_matrix_functions.c:              lnode[1] = E->ien[el].node[2];
General_matrix_functions.c:              lnode[2] = E->ien[el].node[3];
General_matrix_functions.c:              lnode[4] = E->ien[el].node[6];
General_matrix_functions.c:              lnode[3] = E->ien[el].node[7];
General_matrix_functions.c:          for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
General_matrix_functions.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
General_matrix_functions.c:              temp[i+1] += X[lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
General_matrix_functions.c:              temp[i+1+noz] += E->M.vpt[GMVINDEX(d,nint)]
General_matrix_functions.c:    const int vpts = vpoints[E->mesh.nsd];
General_matrix_functions.c:    const int ends = enodes[E->mesh.nsd];
General_matrix_functions.c:    for (el=1;el<=E->mesh.nel;el++)  {
General_matrix_functions.c:          get_global_shape_fn(E,el,&GN,&GNx,&dOmega,0,E->mesh.levmax);
General_matrix_functions.c:                n = E->ien[el].node[i];
General_matrix_functions.c:                volume += E->N.vpt[GNVINDEX(i,j)] * dOmega.vpt[j];
General_matrix_functions.c:                integral += Z[n] * E->N.vpt[GNVINDEX(i,j)] * dOmega.vpt[j];
General_matrix_functions.c:    neq=E->mesh.NEQ[lev];
Geometry_cartesian.c:  E->mesh.nsd = 2;
Geometry_cartesian.c:  E->mesh.dof = 2;
Geometry_cartesian.c:  E->mesh.nsd = 2;
Geometry_cartesian.c:  E->mesh.dof = 3;
Geometry_cartesian.c:  E->mesh.nsd = 3;
Geometry_cartesian.c:  E->mesh.dof = 3;
Instructions.c:    E->control.PID=get_process_identifier(); 
Instructions.c:    (E->problem_derived_values)(E);   /* call this before global_derived_  */
Instructions.c:    (E->problem_allocate_vars)(E);
Instructions.c:    (E->solver_allocate_vars)(E);
Instructions.c:    (E->problem_boundary_conds)(E);
Instructions.c:    (E->problem_initial_fields)(E);   /* temperature/chemistry/melting etc */
Instructions.c:    E->P = (double *) malloc ((E->mesh.npno+1)*sizeof(double));
Instructions.c:    E->S = (double *) malloc ((E->mesh.npno+1)*sizeof(double));
Instructions.c:    E->C        = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:    E->CE       = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:    E->T        = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:    E->buoyancy = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:    E->NP       = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:    E->edot     = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:    E->heating_visc    = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:    E->heating_latent    = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:    E->heating_adi    = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:    E->Fas670    = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:    E->Fas670_b  = (float *) malloc((E->mesh.nsf+1)*sizeof(float));
Instructions.c:    E->Fas410    = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:    E->Fas410_b  = (float *) malloc((E->mesh.nsf+1)*sizeof(float));
Instructions.c:  for(i=1;i<=E->mesh.nsd;i++)  {
Instructions.c:    E->TB[i] = (float *)  malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:    E->CB[i] = (float *)  malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:    E->Have.T    = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:    E->Have.Vi   = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:    E->Have.Rho  = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:    E->Have.vrms = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:    E->stress    = (float *)malloc((2*6*E->mesh.nsf+12)*sizeof(float));
Instructions.c:    E->slice.tpg      = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:    E->slice.tpgb     = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:    E->slice.vline     = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:    E->slice.vlinek    = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:    E->slice.shflux    = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:    E->slice.bhflux    = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:    E->slice.cen_mflux = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:    E->slice.vxsurf[1] = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:    E->slice.vxsurf[2] = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:    E->mat = (int *) malloc((E->mesh.nel+2)*sizeof(int));
Instructions.c:  E->XP[1] = (float *)  malloc((E->mesh.nox+1)*sizeof(float));
Instructions.c:  E->XP[2] = (float *)  malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:  for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)   {
Instructions.c:    for(j=1;j<=E->mesh.nsd;j++)   {
Instructions.c:      E->XX[i][j] = (float *)  malloc((E->mesh.NNO[i]+1)*sizeof(float));
Instructions.c:      E->Interp[i][j] = (float *)  malloc((E->mesh.NNO[i]+1)*sizeof(float));
Instructions.c:    E->MASS[i]     = (float *) malloc((E->mesh.NNO[i]+1)*sizeof(float));
Instructions.c:    E->ECO[i] = (struct COORD *) malloc((E->mesh.NNO[i]+2)*sizeof(struct COORD));
Instructions.c:    E->ID[i]  = (struct ID *)    malloc((E->mesh.NNO[i]+2)*sizeof(struct ID));
Instructions.c:    E->IEN[i] = (struct IEN *)   malloc((E->mesh.NEL[i]+2)*sizeof(struct IEN));
Instructions.c:    E->EL[i]  = (struct SUBEL *) malloc((E->mesh.NEL[i]+2)*sizeof(struct SUBEL));
Instructions.c:    E->LMD[i] = (struct LM *)    malloc((E->mesh.NEL[i]+2)*sizeof(struct LM));
Instructions.c:    E->elt_del[i]=(struct EG *)  malloc((E->mesh.NEL[i]+1)*sizeof(struct EG));
Instructions.c:    E->BPI[i]    = (double *)    malloc((E->mesh.NPNO[i]+1)*sizeof(double));
Instructions.c:    E->EVI[i] = (float *) malloc((E->mesh.NEL[i]+2)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:    E->TW[i]  = (float  *)       malloc((E->mesh.NNO[i]+2)*sizeof(float));
Instructions.c:    E->VI[i]  = (float *)        malloc((E->mesh.NNO[i]+2)*sizeof(float));
Instructions.c:    E->NODE[i] = (unsigned int *)malloc((E->mesh.NNO[i]+2)*sizeof(unsigned int));
Instructions.c:      E->TWW[i] =(struct FNODE *) malloc((E->mesh.NEL[i]+2)*sizeof(struct FNODE));
Instructions.c:    E->NEI[i].nels     = (int *) malloc((E->mesh.NNO[i]+2)*sizeof(int));
Instructions.c:    E->NEI[i].lnode    = (int *) malloc((E->mesh.NNO[i]+2)*enodes[E->mesh.nsd]*sizeof(int));
Instructions.c:    E->NEI[i].element  = (int *) malloc((E->mesh.NNO[i]+2)*enodes[E->mesh.nsd]*sizeof(int));   
Instructions.c:  for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)  {
Instructions.c:    if (E->mesh.nsd==2)  {
Instructions.c:        nxyz = max(E->mesh.nox,E->mesh.noz);
Instructions.c:    else if (E->mesh.nsd==3)  {
Instructions.c:        nxyz = max(E->mesh.nox*E->mesh.noz,E->mesh.nox*E->mesh.noy);
Instructions.c:        nxyz = 2*max(nxyz,E->mesh.noz*E->mesh.noy);
Instructions.c:    E->sien         = (struct SIEN *) malloc((nxyz+2)*sizeof(struct SIEN));
Instructions.c:    E->surf_element = (int *) malloc((nxyz+2)*sizeof(int));
Instructions.c:    E->surf_node    = (int *)malloc((E->mesh.nsf+2)*sizeof(int));
Instructions.c:  for(i=1;i<=E->mesh.nno;i++)     {
Instructions.c:    E->T[i] = E->buoyancy[i] = 0.0;
Instructions.c:    for(j=1;j<=E->mesh.nsd;j++)
Instructions.c:      E->TB[j][i] = 0.0;
Instructions.c:  for(l=E->mesh.levmin;l<=E->mesh.levmax;l++)
Instructions.c:    for(i=1;i<=E->mesh.NNO[l];i++)  {
Instructions.c:      E->NODE[l][i] = (INTX | INTY | INTZ);  /* and any others ... */
Instructions.c:      E->VI[l][i] = 1.0;
Instructions.c:      E->TW[l][i] = 0.0;
Instructions.c:      for(j=1;j<=E->mesh.nsd;j++)
Instructions.c:         E->XX[l][j][i] = 0.0;
Instructions.c:  for(i=1;i<E->mesh.nel;i++)   {
Instructions.c:     E->mat[i]=1;
Instructions.c:     E->heating_visc[i] =  E->heating_latent[i] = E->heating_adi[i] = 0.0;
Instructions.c:  for(i=1;i<=E->mesh.npno;i++)
Instructions.c:      E->P[i] = 0.0;
Instructions.c:  E->mesh.nnov = E->mesh.nno;
Instructions.c:  E->mesh.NEQ[E->mesh.levmax] = E->mesh.nnov * E->mesh.nsd;
Instructions.c:  E->F = (double *) malloc((E->mesh.nsd*E->mesh.nnov+1)*sizeof(double));
Instructions.c:  E->U = (double *) malloc((E->mesh.nsd*E->mesh.nnov+1)*sizeof(double));
Instructions.c:  for(i=1;i<=E->mesh.nsd;i++)  {
Instructions.c:      E->V[i]  = (float *)  malloc((E->mesh.nnov+1)*sizeof(float));
Instructions.c:      E->VB[i] = (float *)  malloc((E->mesh.nnov+1)*sizeof(float));
Instructions.c:  for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)  {
Instructions.c:    E->BI[i] = (double *) malloc((E->mesh.NEQ[i]+2)*sizeof(double)); 
Instructions.c:    E->EQN[i] = (unsigned int *) malloc((E->mesh.NEQ[i]+2)*sizeof(unsigned int)); 
Instructions.c:  for(l=E->mesh.levmin;l<=E->mesh.levmax;l++)
Instructions.c:    for(i=0;i<E->mesh.NEQ[l];i++) {
Instructions.c:      E->BI[l][i]=0.0;
Instructions.c:      E->EQN[l][i]=0;
Instructions.c:  for(i=0;i<E->mesh.NEQ[E->mesh.levmax];i++)
Instructions.c:    E->U[i]=0.0;
Instructions.c:  for(i=1;i<=E->mesh.nnov;i++)
Instructions.c:    for(j=1;j<=E->mesh.nsd;j++)
Instructions.c:       E->V[j][i] =
Instructions.c:         E->VB[j][i] = 0.0;
Instructions.c:  E->control.v_steps_low = 10;
Instructions.c:  E->control.v_steps_upper = 1;
Instructions.c:  E->control.max_res_red_each_p_mg = 1.0e-3;
Instructions.c:  E->control.accuracy = 1.0e-6;
Instructions.c:  E->control.vaccuracy = 1.0e-8;
Instructions.c:  E->control.true_vcycle=0;
Instructions.c:  E->control.depth_dominated=0;
Instructions.c:  E->control.eqn_zigzag=0;
Instructions.c:  E->control.verbose=0; /* debugging/profiles */
Instructions.c:  E->control.ORTHO = 1; /* for orthogonal meshes by default */
Instructions.c:  E->control.ORTHOZ = 1; /* for orthogonal meshes by default */
Instructions.c:    E->control.KERNEL = 0;
Instructions.c:    E->control.stokes=0;
Instructions.c:    E->control.CONVECTION = 0;
Instructions.c:    E->control.CART2D = 0;
Instructions.c:    E->control.CART3D = 0;
Instructions.c:    E->control.CART2pt5D = 0;
Instructions.c:    E->control.AXI = 0;
Instructions.c:    E->control.CONJ_GRAD = 0;
Instructions.c:    E->control.NMULTIGRID = 0;
Instructions.c:    E->control.EMULTIGRID = 0;
Instructions.c:    E->control.COMPRESS = 1;
Instructions.c:    E->control.augmented_Lagr = 0;
Instructions.c:    E->control.augmented = 0.0;
Instructions.c:    E->control.MELTING_MODULE = 0;
Instructions.c:    E->control.CHEMISTRY_MODULE = 0;
Instructions.c:    E->control.composition = 0;
Instructions.c:    E->control.comp_diff = 0.0;
Instructions.c:    E->control.composition_phasechange = 0;
Instructions.c:    E->control.GRID_TYPE=1;
Instructions.c:    E->mesh.hwidth[1]=E->mesh.hwidth[2]=E->mesh.hwidth[3]=1.0; /* divide by this one ! */
Instructions.c:    E->mesh.magnitude[1]=E->mesh.magnitude[2]=E->mesh.magnitude[3]=0.0;
Instructions.c:    E->mesh.offset[1]=E->mesh.offset[2]=E->mesh.offset[3]=0.0;
Instructions.c:  E->mesh.levmax=0;
Instructions.c:  E->mesh.levmin=0;
Instructions.c:  E->mesh.noz = 1;    E->mesh.noz = 1;
Instructions.c:  E->mesh.noy = 1;    E->mesh.noy = 1;  
Instructions.c:  E->monitor.T_interior=1.0;
Instructions.c:  E->viscosity.guess = 0;
Instructions.c:  sprintf(E->viscosity.old_file,"initialize");
Instructions.c:  E->control.precondition = 0;	/* for larger visc contrasts turn this back on  */
Instructions.c:  E->control.vprecondition = 1;	
Instructions.c:  E->mesh.toptbc = 1; /* fixed t */
Instructions.c:  E->mesh.bottbc = 1;
Instructions.c:  E->mesh.topvbc = 0; /* stress */
Instructions.c:  E->mesh.botvbc = 0;
Instructions.c:  E->mesh.sidevbc=0;
Instructions.c:  E->mesh.periodic_x=0; /* reflection is default*/
Instructions.c:  E->mesh.periodic_y=0;
Instructions.c:  E->control.VBXtopval=0.0;
Instructions.c:  E->control.VBYtopval=0.0;
Instructions.c:  E->control.VBXbotval=0.0;
Instructions.c:  E->control.VBYbotval=0.0;
Instructions.c:  E->data.layer_km = 2800.0; /* Earth, whole mantle defaults */
Instructions.c:  E->data.grav_acc = 9.81;
Instructions.c:  E->data.therm_exp = 3.28e-5;
Instructions.c:  E->data.therm_exp_factor=1.0;
Instructions.c:  E->data.visc_factor=1.0;
Instructions.c:  E->data.Cp = 1200.0;
Instructions.c:  E->data.therm_diff = 8.0e-7;
Instructions.c:  E->data.therm_cond = 3.168;
Instructions.c:  E->data.density = 3340.0;
Instructions.c:  E->data.res_density = 3295.0;  /* density when X = ... */
Instructions.c:  E->data.res_density_X = 0.3;
Instructions.c:  E->data.melt_density = 2800.0;
Instructions.c:  E->data.permeability = 3.0e-10;
Instructions.c:  E->data.density_above = 1030.0;    /* sea water */
Instructions.c:  E->data.gas_const = 8.3;
Instructions.c:  E->data.surf_heat_flux = 4.4e-2;
Instructions.c:  E->data.grav_const = 6.673e-11;
Instructions.c:  E->data.surf_temp = 0.0;
Instructions.c:  E->data.youngs_mod = 1.0e11;
Instructions.c:  E->data.Te = 0.0;
Instructions.c:  E->data.T_sol0 = 1373.0;	/* Dave's values 1991 (for the earth) */
Instructions.c:  E->data.Tsurf = 273.0;
Instructions.c:  E->data.dTsol_dz = 3.4e-3 ;
Instructions.c:  E->data.dTsol_dF = 440.0;
Instructions.c:  E->data.dT_dz = 0.48e-3;
Instructions.c:  E->data.delta_S = 250.0;
Instructions.c:  E->data.ref_temperature = 2 * 1350.0; /* fixed temperature ... delta T */
Instructions.c:    sprintf(E->control.data_file,"citcom.tmp.%d",getpid());
Instructions.c:    E->control.NASSEMBLE = 0;
Instructions.c:    E->mesh.layer[1] =  E->mesh.layer[2] =  E->mesh.layer[3] = 1.0;
Instructions.c:    E->monitor.elapsed_time=0.0;
Instructions.c: if (E->control.NMULTIGRID||E->control.EMULTIGRID)
Instructions.c:    { E->mesh.levmax=E->mesh.levels-1;
Instructions.c:      E->mesh.nox = E->mesh.mgunitx * (int) pow(2.0,((double)E->mesh.levmax)) + 1;
Instructions.c:      E->mesh.noz = E->mesh.mgunitz *(int) pow(2.0,((double)E->mesh.levmax)) + 1; 
Instructions.c:      if(E->mesh.nsd == 3 ) 
Instructions.c:	  E->mesh.noy = E->mesh.mgunity * (int) pow(2.0,((double)E->mesh.levmax)) + 1; 
Instructions.c: if(E->mesh.nsd != 3) 
Instructions.c:   E->mesh.noy = 1;
Instructions.c:  E->mesh.nnx[1] = E->mesh.nox;	
Instructions.c:  E->mesh.nnx[2] = E->mesh.noz;	
Instructions.c:  E->mesh.nnx[3] = E->mesh.noy;	
Instructions.c:  E->mesh.elx = E->mesh.nox-1;	
Instructions.c:  E->mesh.elz = E->mesh.noz-1;
Instructions.c:  E->mesh.ely = max(E->mesh.noy-1,1);
Instructions.c:  E->mesh.nel = E->mesh.elx*E->mesh.ely*E->mesh.elz;
Instructions.c:  E->mesh.nno = E->mesh.nox*E->mesh.noy*E->mesh.noz;
Instructions.c:  E->mesh.nnov = E->mesh.nno;
Instructions.c:  E->mesh.neq = E->mesh.nnov*E->mesh.nsd;
Instructions.c:  E->mesh.npno = E->mesh.nel;
Instructions.c:  E->mesh.nsf = E->mesh.nox*E->mesh.noy;
Instructions.c:  for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)  /* set up dimensions for different grids  */
Instructions.c:    { if (E->control.NMULTIGRID||E->control.EMULTIGRID)
Instructions.c:	{ nox = E->mesh.mgunitx * (int) pow(2.0,(double)i) + 1;
Instructions.c:	  noz = E->mesh.mgunitz * (int) pow(2.0,(double)i) + 1;
Instructions.c:	  if(E->mesh.nsd==3)
Instructions.c:	    noy = E->mesh.mgunity * (int) pow(2.0,(double)i) + 1;
Instructions.c:	{ nox = E->mesh.nox;
Instructions.c:	  noz = E->mesh.noz;
Instructions.c:	  noy = E->mesh.noy;
Instructions.c:      E->mesh.ELX[i] = nox-1;
Instructions.c:      E->mesh.ELZ[i] = noz-1;
Instructions.c:      E->mesh.ELY[i] = max(noy-1,1);
Instructions.c:      E->mesh.NNO[i] = nox * noz * noy;
Instructions.c:      E->mesh.NEL[i] = (nox-1) * (noz-1) * max((noy-1),1);;
Instructions.c:      E->mesh.NPNO[i] = E->mesh.NEL[i] ;
Instructions.c:      E->mesh.NOX[i] = nox;
Instructions.c:      E->mesh.NOZ[i] = noz;
Instructions.c:      E->mesh.NOY[i] = noy;
Instructions.c:      E->mesh.NNX[i][1] = nox;	
Instructions.c:      E->mesh.NNX[i][2] = noz;	
Instructions.c:      E->mesh.NNX[i][3] = noy;	
Instructions.c:      E->mesh.NNOV[i] = E->mesh.NNO[i];
Instructions.c:      E->mesh.NEQ[i] = E->mesh.nsd * E->mesh.NNOV[i] ;  
Instructions.c:    if(E->control.print_convergence)
Instructions.c:	fprintf(stderr,"Problem has %d x %d x %d nodes\n",E->mesh.nox,E->mesh.noz,E->mesh.noy);
Instructions.c:    input_string("Problem",E->control.PROBLEM_TYPE,NULL);
Instructions.c:    if ( strcmp(E->control.PROBLEM_TYPE,"convection") == 0)  {
Instructions.c:	E->control.CONVECTION = 1; 
Instructions.c:    else if ( strcmp(E->control.PROBLEM_TYPE,"convection-chemical") == 0) {
Instructions.c:	E->control.CONVECTION = 1;
Instructions.c:	E->control.CHEMISTRY_MODULE=1;
Instructions.c:	fprintf(E->fp,"Unable to determine problem type, assuming convection ... \n");
Instructions.c:	E->control.CONVECTION = 1;
Instructions.c:  input_string("Geometry",E->control.GEOMETRY,NULL); 
Instructions.c:  if ( strcmp(E->control.GEOMETRY,"cart2d") == 0)
Instructions.c:    { E->control.CART2D = 1; 
Instructions.c:  else if ( strcmp(E->control.GEOMETRY,"axi") == 0)
Instructions.c:    { E->control.AXI = 1; 
Instructions.c:  else if ( strcmp(E->control.GEOMETRY,"cart2pt5d") == 0)
Instructions.c:    { E->control.CART2pt5D = 1; 
Instructions.c:  else if ( strcmp(E->control.GEOMETRY,"cart3d") == 0)
Instructions.c:    { E->control.CART3D = 1;
Instructions.c:    { fprintf(E->fp,"Unable to determine geometry, assuming cartesian 2d ... \n");
Instructions.c:      E->control.CART2D = 1; 
Instructions.c:  input_string("Solver",E->control.SOLVER_TYPE,NULL);
Instructions.c:  if ( strcmp(E->control.SOLVER_TYPE,"cgrad") == 0)
Instructions.c:    { E->control.CONJ_GRAD = 1;
Instructions.c:  else if ( strcmp(E->control.SOLVER_TYPE,"multigrid") == 0)
Instructions.c:    { E->control.NMULTIGRID = 1;
Instructions.c:  else if ( strcmp(E->control.SOLVER_TYPE,"multigrid-el") == 0)
Instructions.c:    { E->control.EMULTIGRID = 1;
Instructions.c:  input_string("Spacing",E->control.NODE_SPACING,"regular");
Instructions.c:  if ( strcmp(E->control.NODE_SPACING,"regular") == 0)
Instructions.c:    E->control.GRID_TYPE = 1; 
Instructions.c:  else if ( strcmp(E->control.NODE_SPACING,"bound_lyr") == 0)
Instructions.c:    E->control.GRID_TYPE = 2;
Instructions.c:  else if ( strcmp(E->control.NODE_SPACING,"region") == 0)
Instructions.c:    E->control.GRID_TYPE = 3;
Instructions.c:  else if ( strcmp(E->control.NODE_SPACING,"ortho_files") == 0)
Instructions.c:    E->control.GRID_TYPE = 4;
Instructions.c:    {  E->control.GRID_TYPE = 1; }
Instructions.c:    input_string("datatypes",E->control.which_data_files,"");
Instructions.c:    input_string("averages",E->control.which_horiz_averages,"");
Instructions.c:    input_string("timelog",E->control.which_running_data,"");
Instructions.c:    input_string("observables",E->control.which_observable_data,"");
Instructions.c:    input_string("datafile",E->control.data_file,"initialize");
Instructions.c:    input_string("restart_datafile",E->control.data_file1,"initialize");
Instructions.c:    input_string("process_command",E->control.output_written_external_command,"");
Instructions.c:    input_boolean("CONMAN",&(E->control.CONMAN),"off");
Instructions.c:    input_boolean("imposevelo",&(E->control.imposevelo),"off");
Instructions.c:    input_int("age_total",&(E->control.age_total),"130");
Instructions.c:    input_string("velo_file_pre",E->control.velo_file_pre,"SurfVelo130_");
Instructions.c:    input_string("velo_file_post",E->control.velo_file_post,".dat");
Instructions.c:    input_float("timescale",&(E->control.timescale),"261100.0");
Instructions.c:    input_float("age_total_float",&(E->control.age_total_float),"130.0");
Instructions.c:    input_boolean("ocean_lith",&(E->control.ocean_lith),"off");
Instructions.c:    input_boolean("platemodel",&(E->control.platemodel),"off");
Instructions.c:    input_float("inter_temp",&(E->control.inter_temp),"0.5196");
Instructions.c:    input_float("age_left",&(E->control.age_left),"100.0");
Instructions.c:    input_float("age_right",&(E->control.age_right),"0.0");
Instructions.c:    input_float("age_loc_left",&(E->control.age_loc_left),"1.0");
Instructions.c:    input_float("age_loc_right",&(E->control.age_loc_right),"2.0");
Instructions.c:    input_float("depth_lith",&(E->control.depth_lith),"0.95644599");
Instructions.c:    input_boolean("ocean_lith_margin",&(E->control.ocean_lith_margin),"off");
Instructions.c:    input_float("depth_lith_margin",&(E->control.depth_lith_margin),"0.9303");
Instructions.c:    input_float("dip_margin",&(E->control.dip_margin),"45.0");
Instructions.c:    input_float("depth_ocean_lith",&(E->control.depth_ocean_lith),"0.95644599");
Instructions.c:    input_boolean("visc_platebond",&(E->control.visc_platebond),"off");
Instructions.c:    input_float("y_weakzone_platebond",&(E->control.y_weakzone_platebond),"0.95644599");
Instructions.c:    input_float("width_weakzone_platebond",&(E->control.width_weakzone_platebond),"0.0348432");
Instructions.c:    input_boolean("continent_lith",&(E->control.continent_lith),"off");
Instructions.c:    input_float("depth_continent_lith",&(E->control.depth_continent_lith),"0.95644599");
Instructions.c:    input_float("continent_loc_left",&(E->control.continent_loc_left),"0.0");
Instructions.c:    input_float("continent_loc_right",&(E->control.continent_loc_right),"1.0");
Instructions.c:    input_boolean("slab_visc",&(E->control.slab_visc),"off");
Instructions.c:    input_float("slab_visc_depth",&(E->control.slab_visc_depth),"0.76655");
Instructions.c:    input_float("viscincreaseslab",&(E->control.viscincreaseslab),"10.0");
Instructions.c:    input_float("temp_slabvisc",&(E->control.temp_slabvisc),"0.05");
Instructions.c:    input_boolean("visc_const_cor",&(E->control.visc_const_cor),"off");
Instructions.c:    input_boolean("visc_leftcor",&(E->control.visc_leftcor),"off");
Instructions.c:    input_boolean("visc_rightcor",&(E->control.visc_rightcor),"off");
Instructions.c:    input_boolean("visc_mid",&(E->control.visc_mid),"off");
Instructions.c:    input_boolean("visc_mid_dip",&(E->control.visc_mid_dip),"off");
Instructions.c:    input_float("visc_weakzone",&(E->control.visc_weakzone),"0.001");
Instructions.c:    input_float("x_weakzone_leftcor",&(E->control.x_weakzone_leftcor),"0.01");
Instructions.c:    input_float("x_weakzone_rightcor",&(E->control.x_weakzone_rightcor),"0.99");
Instructions.c:    input_float("x_weakzone_mid_left",&(E->control.x_weakzone_mid_left),"0.45");
Instructions.c:    input_float("x_weakzone_mid_right",&(E->control.x_weakzone_mid_right),"0.55");
Instructions.c:    input_float("dip_weakzone_mid",&(E->control.dip_weakzone_mid),"30.0");
Instructions.c:    input_float("left_weakzone_platebond",&(E->control.left_weakzone_platebond),"0.0348432");
Instructions.c:    input_float("right_weakzone_platebond",&(E->control.right_weakzone_platebond),"0.0");
Instructions.c:    input_float("y_weakzone_leftcor",&(E->control.y_weakzone_leftcor),"0.97");
Instructions.c:    input_float("y_weakzone_rightcor",&(E->control.y_weakzone_rightcor),"0.97");
Instructions.c:    input_float("y_weakzone_mid",&(E->control.y_weakzone_mid),"0.97");
Instructions.c:    input_boolean("phasevisc",&(E->control.phasevisc),"off");
Instructions.c:    input_float("phaseTop",&(E->control.phaseTop),"0.0871");
Instructions.c:    input_float("phaseBot",&(E->control.phaseBot),"0.0871");
Instructions.c:    input_float("phaseffactorLa",&(E->control.phaseffactorLa),"0.95");
Instructions.c:    input_float("phaseffactorSm",&(E->control.phaseffactorSm),"0.05");
Instructions.c:    input_boolean("phasevisc_slab",&(E->control.phasevisc_slab),"off");
Instructions.c:    input_float("ViscReduce",&(E->control.ViscReduce),"0.01");
Instructions.c:    input_float("phasevisc_slab_T",&(E->control.phasevisc_slab_T),"-0.01");
Instructions.c:    input_boolean("phasevisc_C",&(E->control.phasevisc_C),"off");
Instructions.c:    input_float("velo_surf_loc_mid",&(E->control.velo_surf_loc_mid),"1.0");
Instructions.c:    input_float("velo_surf_mag_right",&(E->control.velo_surf_mag_right),"-1000.0");
Instructions.c:    input_float("velo_surf_width_right",&(E->control.velo_surf_width_right),"50.0");
Instructions.c:    input_boolean("trechmigrate",&(E->control.trechmigrate),"off");
Instructions.c:    input_float("velo_surf_mag_left",&(E->control.velo_surf_mag_left),"-1000.0");
Instructions.c:    input_float("velo_surf_width_left",&(E->control.velo_surf_width_left),"50.0");
Instructions.c:    input_float("velo_surf_width_mid",&(E->control.velo_surf_width_mid),"50.0");
Instructions.c:    input_float("velo_surf_corner_right",&(E->control.velo_surf_corner_right),"50.0");
Instructions.c:    input_float("velo_surf_loc_mid_rate",&(E->control.velo_surf_loc_mid_rate),"0.003484");
Instructions.c:    input_float("velo_surf_loc_left_overshoot",&(E->control.velo_surf_loc_left_overshoot),"0.02998955");
Instructions.c:    sprintf(logfile,"%s.log",E->control.data_file);
Instructions.c:	E->fp = stdout;
Instructions.c:	E->fp = fp;
Instructions.c:    if (E->control.NMULTIGRID||E->control.EMULTIGRID) {
Instructions.c:	input_int("mgunitx",&(E->mesh.mgunitx),"1");
Instructions.c:	input_int("mgunitz",&(E->mesh.mgunitz),"1");
Instructions.c:	input_int("mgunity",&(E->mesh.mgunity),"1");
Instructions.c:	input_int("levels",&(E->mesh.levels),"0");
Instructions.c:    input_boolean("node_assemble",&(E->control.NASSEMBLE),"off");
Instructions.c:    input_boolean("verbose",&(E->control.verbose),"off");
Instructions.c:    input_boolean("see_convergence",&(E->control.print_convergence),"off");
Instructions.c:    input_boolean("COMPRESS",&(E->control.COMPRESS),"on");
Instructions.c:    input_float("sobtol",&(E->control.sob_tolerance),"0.0001");
Instructions.c:    input_int("obs_maxlongk",&(E->slice.maxlong),"100,1");
Instructions.c:    input_int("obs_minlongk",&(E->slice.minlong),"1,1");
Instructions.c:    input_int("stokes_flow_only",&(E->control.stokes),"0");
Instructions.c:    input_int("slab_nz",&(E->control.SLAB),"1");
Instructions.c:    input_int("plume_nz",&(E->control.PLUME),"1");
Instructions.c:    input_float("Ra_670",&(E->control.Ra_670),"0.0");
Instructions.c:    input_float("clapeyron670",&(E->control.clapeyron670),"0.0");
Instructions.c:    input_float("transT670",&(E->control.transT670),"0.0");
Instructions.c:    input_float("width670",&(E->control.width670),"0.0");
Instructions.c:    input_float("Ra_410",&(E->control.Ra_410),"0.0");
Instructions.c:    input_float("clapeyron410",&(E->control.clapeyron410),"0.0");
Instructions.c:    input_float("transT410",&(E->control.transT410),"0.0");
Instructions.c:    input_float("width410",&(E->control.width410),"0.0");
Instructions.c:    input_int("restart",&(E->control.restart),"0");
Instructions.c:    input_int("topvbc",&(E->mesh.topvbc),"0");
Instructions.c:    input_int("botvbc",&(E->mesh.botvbc),"0");
Instructions.c:    input_int("sidevbc",&(E->mesh.sidevbc),"0");
Instructions.c:    input_boolean("periodicx",&(E->mesh.periodic_x),"off");
Instructions.c:    input_boolean("periodicy",&(E->mesh.periodic_y),"off");
Instructions.c:    input_boolean("depthdominated",&(E->control.depth_dominated),"off");
Instructions.c:    input_boolean("eqnzigzag",&(E->control.eqn_zigzag),"off");
Instructions.c:    input_boolean("eqnviscosity",&(E->control.eqn_viscosity),"off");
Instructions.c:    input_float("topvbxval",&(E->control.VBXtopval),"0.0");
Instructions.c:    input_float("botvbxval",&(E->control.VBXbotval),"0.0");
Instructions.c:    input_float("topvbyval",&(E->control.VBYtopval),"0.0");
Instructions.c:    input_float("botvbyval",&(E->control.VBYbotval),"0.0");
Instructions.c:    input_int("toptbc",&(E->mesh.toptbc),"1");
Instructions.c:    input_int("bottbc",&(E->mesh.bottbc),"1");
Instructions.c:    input_float("toptbcval",&(E->control.TBCtopval),"0.0");
Instructions.c:    input_float("bottbcval",&(E->control.TBCbotval),"1.0");
Instructions.c:    input_float("blyr_hwx1",&(E->mesh.bl1width[1]),"nodefault");
Instructions.c:    input_float("blyr_hwz1",&(E->mesh.bl1width[2]),"nodefault");
Instructions.c:    input_float("blyr_hwy1",&(E->mesh.bl1width[3]),"nodefault");
Instructions.c:    input_float("blyr_hwx2",&(E->mesh.bl2width[1]),"nodefault");
Instructions.c:    input_float("blyr_hwz2",&(E->mesh.bl2width[2]),"nodefault");
Instructions.c:    input_float("blyr_hwy2",&(E->mesh.bl2width[3]),"nodefault");
Instructions.c:    input_float("blyr_mgx1",&(E->mesh.bl1mag[1]),"nodefault");
Instructions.c:    input_float("blyr_mgz1",&(E->mesh.bl1mag[2]),"nodefault");
Instructions.c:    input_float("blyr_mgy1",&(E->mesh.bl1mag[3]),"nodefault");
Instructions.c:    input_float("blyr_mgx2",&(E->mesh.bl2mag[1]),"nodefault");
Instructions.c:    input_float("blyr_mgz2",&(E->mesh.bl2mag[2]),"nodefault");
Instructions.c:    input_float("blyr_mgy2",&(E->mesh.bl2mag[3]),"nodefault");
Instructions.c:    input_float("region_wdx",&(E->mesh.width[1]),"nodefault");
Instructions.c:    input_float("region_wdz",&(E->mesh.width[2]),"nodefault");
Instructions.c:    input_float("region_wdy",&(E->mesh.width[3]),"nodefault");
Instructions.c:    input_float("region_hwx",&(E->mesh.hwidth[1]),"nodefault");
Instructions.c:    input_float("region_hwz",&(E->mesh.hwidth[2]),"nodefault");
Instructions.c:    input_float("region_hwy",&(E->mesh.hwidth[3]),"nodefault");
Instructions.c:    input_float("region_mgx",&(E->mesh.magnitude[1]),"nodefault");
Instructions.c:    input_float("region_mgz",&(E->mesh.magnitude[2]),"nodefault");
Instructions.c:    input_float("region_mgy",&(E->mesh.magnitude[3]),"nodefault");
Instructions.c:    input_float("region_ofx",&(E->mesh.offset[1]),"nodefault");
Instructions.c:    input_float("region_ofz",&(E->mesh.offset[2]),"nodefault");
Instructions.c:    input_float("region_ofy",&(E->mesh.offset[3]),"nodefault");
Instructions.c:    input_string("gridxfile",E->mesh.gridfile[1]," ");
Instructions.c:    input_string("gridzfile",E->mesh.gridfile[2]," ");
Instructions.c:    input_string("gridyfile",E->mesh.gridfile[3]," ");
Instructions.c:    input_float("layerd",&(E->data.layer_km),"2800.0");
Instructions.c:    E->data.layer_meter = E->data.layer_km*1000;
Instructions.c:    E->viscosity.zlm = 0.76655;
Instructions.c:    E->viscosity.zlith = 0.95644599;
Instructions.c:    input_int("nz_lmantle",&(E->viscosity.nlm),"1");
Instructions.c:    input_int("nz_410",&(E->viscosity.n410),"1");
Instructions.c:    input_int("nz_lith",&(E->viscosity.nlith),"1");
Instructions.c:    input_int("nz_mid_moho",&(E->viscosity.ncrust2),"1");
Instructions.c:    input_float("z_lmantle",&(E->viscosity.zlm),"0.76655");
Instructions.c:    input_float("z_410",&(E->viscosity.z410),"0.85714");
Instructions.c:    input_float("z_lith",&(E->viscosity.zlith),"0.95644599");
Instructions.c:    input_float("z_mid_moho",&(E->viscosity.zcrust2),"0.0");
Instructions.c:    input_float("z_300",&(E->viscosity.z300),"0.89547");
Instructions.c:    input_float("z_1000",&(E->viscosity.z1000),"0.6515679");
Instructions.c:    input_float("z_comp",&(E->viscosity.zcrust1),"0.0");
Instructions.c:    input_float("dimenx",&(E->mesh.layer[1]),"nodefault");
Instructions.c:    input_float("dimenz",&(E->mesh.layer[2]),"nodefault");
Instructions.c:    input_int("nodex",&(E->mesh.nox),"nodefault,1,nomax");
Instructions.c:    input_int("nodez",&(E->mesh.noz),"nodefault,1,nomax");
Instructions.c:    input_int("nodey",&(E->mesh.noy),"1,1,nomax");
Instructions.c:    input_boolean("aug_lagr",&(E->control.augmented_Lagr),"off");
Instructions.c:    input_double("aug_number",&(E->control.augmented),"0.0");
Instructions.c:    input_float("tole_compressibility",&(E->control.tole_comp),"0.0");
Instructions.c:    input_boolean("orthogonal",&(E->control.ORTHO),"on");
Instructions.c:    input_int("storage_spacing",&(E->control.record_every),"10");
Instructions.c:    input_int("storage_always_before",&(E->control.record_all_until),"5");
Instructions.c:    input_boolean("precond",&(E->control.precondition),"off");
Instructions.c:    input_boolean("vprecond",&(E->control.vprecondition),"on");
Instructions.c:    input_int("mg_cycle",&(E->control.mg_cycle),"2,0,nomax");
Instructions.c:    input_int("down_heavy",&(E->control.down_heavy),"1,0,nomax");
Instructions.c:    input_int("up_heavy",&(E->control.up_heavy),"1,0,nomax");
Instructions.c:    input_double("accuracy",&(E->control.accuracy),"1.0e-4,0.0,1.0");
Instructions.c:    input_int("viterations",&(E->control.max_vel_iterations),"250,0,nomax");
Instructions.c:    input_int("vhighstep",&(E->control.v_steps_high),"1,0,nomax");
Instructions.c:    input_int("vlowstep",&(E->control.v_steps_low),"250,0,nomax");
Instructions.c:    input_int("vupperstep",&(E->control.v_steps_upper),"1,0,nomax");
Instructions.c:    input_int("piterations",&(E->control.p_iterations),"100,0,nomax");
Instructions.c:    input_int("maxsamevisc",&(E->control.max_same_visc),"25,0,nomax");
Instructions.c:  input_float("Ts",&(E->control.Ts),"0.0");
Instructions.c:  input_float("ReferenceT",&(E->data.ref_temperature),"2600.0");
Instructions.c:  E->data.ref_temperature = E->data.ref_temperature - E->control.Ts;
Instructions.c:  E->control.Ts = E->control.Ts/E->data.ref_temperature;
Instructions.c:  E->rad_heat.num = 0;
Instructions.c:  input_int("num_radioactives",&(E->rad_heat.num),"0");
Instructions.c:  fprintf(E->fp,"n_rad %d\n",E->rad_heat.num);
Instructions.c:  if (E->rad_heat.num!=0)  {
Instructions.c:     input_double("concen_u",&(E->rad_heat.concen_u),"0.0");
Instructions.c:     input_double_vector("percent",E->rad_heat.num,(E->rad_heat.percent));
Instructions.c:     input_double_vector("heat_g",E->rad_heat.num,(E->rad_heat.heat_g));
Instructions.c:     input_double_vector("decay_time",E->rad_heat.num,(E->rad_heat.decay_t));
Instructions.c:     E->rad_heat.concen[0]=E->rad_heat.concen_u;
Instructions.c:     E->rad_heat.concen[1]=E->rad_heat.concen_u;
Instructions.c:     E->rad_heat.concen[2]=E->rad_heat.concen_u*4;
Instructions.c:     E->rad_heat.concen[3]=E->rad_heat.concen_u*10000;
Instructions.c:     fprintf(E->fp,"Rad_heat %.4e %.4e %.4e %.4e\n",E->rad_heat.percent[0],E->rad_heat.heat_g[0],E->rad_heat.decay_t[0],E->rad_heat.concen[0]);
Instructions.c:     fprintf(E->fp,"Rad_heat %.4e %.4e %.4e %.4e\n",E->rad_heat.percent[1],E->rad_heat.heat_g[1],E->rad_heat.decay_t[1],E->rad_heat.concen[1]);
Instructions.c:     fprintf(E->fp,"Rad_heat %.4e %.4e %.4e %.4e\n",E->rad_heat.percent[2],E->rad_heat.heat_g[2],E->rad_heat.decay_t[2],E->rad_heat.concen[2]);
Instructions.c:     fprintf(E->fp,"Rad_heat %.4e %.4e %.4e %.4e\n",E->rad_heat.percent[3],E->rad_heat.heat_g[3],E->rad_heat.decay_t[3],E->rad_heat.concen[3]);
Instructions.c:     fflush(E->fp);
Instructions.c:     input_float("Q0",&(E->control.Q0),"0.0");
Instructions.c:  input_float("gravacc",&(E->data.grav_acc),"9.81");
Instructions.c:  input_float("thermexp",&(E->data.therm_exp),"3.28e-5");
Instructions.c:  input_float("thermexp_factor",&(E->data.therm_exp_factor),"1");
Instructions.c:  input_float("visc_factor",&(E->data.visc_factor),"3.28e-5");
Instructions.c:  input_float("cp",&(E->data.Cp),"1200.0");
Instructions.c:  input_float("thermdiff",&(E->data.therm_diff),"8.0e-7");
Instructions.c:  input_float("thermcond",&(E->data.therm_cond),"3.168");
Instructions.c:  input_float("density",&(E->data.density),"3340.0");
Instructions.c:  input_float("mdensity",&(E->data.melt_density),"2800.0");
Instructions.c:  input_float("wdensity",&(E->data.density_above),"1030.0");
Instructions.c:  input_float("rdensity",&(E->data.res_density),"3295.0");
Instructions.c:  input_float("heatflux",&(E->data.surf_heat_flux),"4.4e-2");
Instructions.c:  input_float("refvisc",&(E->data.ref_viscosity),"nodefault");
Instructions.c:  input_float("meltvisc",&(E->data.melt_viscosity),"nodefault");
Instructions.c:  input_float("surftemp",&(E->data.surf_temp),"0.0");
Instructions.c:  input_float("youngs",&(E->data.youngs_mod),"1.0e11");
Instructions.c:  input_float("Te",&(E->data.Te),"0.0");
Instructions.c:  input_float("Tsol0",&(E->data.T_sol0),"1373.0");
Instructions.c:  input_float("dTsoldz",&(E->data.dTsol_dz),"3.4e-3");
Instructions.c:  input_float("dTsoldF",&(E->data.dTsol_dF),"440.0");
Instructions.c:  input_float("dTdz",&(E->data.dT_dz),"0.48e-3");
Instructions.c:  input_float("deltaS",&(E->data.delta_S),"250.0");
Instructions.c:  input_float("gasconst",&(E->data.gas_const),"8.3");     /* not much cause to change these ! */
Instructions.c:  input_float("gravconst",&(E->data.grav_const),"6.673e-11");
Instructions.c:  input_float("permeability",&(E->data.permeability),"3.0e-10");
Instructions.c:  E->monitor.time_scale = E->data.layer_meter*E->data.layer_meter/(E->data.therm_diff*3600.0*24.0*365.25);   /* years*/
Instructions.c: (E->problem_settings)(E);
Instructions.c:  for(i=1;i<=E->mesh.nno;i++)
Instructions.c:    { if ((E->node[i] & VBX) && (E->node[i] & SBX))
Instructions.c:      if ((E->node[i] & VBZ) && (E->node[i] & SBZ))
Instructions.c:      if ((E->node[i] & VBY) && (E->node[i] & SBY))
Instructions.c:      if ((E->node[i] & TBX) && (E->node[i] & FBX))
Instructions.c:      if ((E->node[i] & TBZ) && (E->node[i] & FBZ))
Instructions.c:      if ((E->node[i] & TBY) && (E->node[i] & FBY))
Instructions.c:  for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Instructions.c:    for(i=1;i<=E->mesh.NNO[lev];i++)
Instructions.c:      { if ((E->NODE[lev][i] & VBX) && (E->NODE[lev][i]  & SBX))
Instructions.c:	if ((E->NODE[lev][i]  & VBZ) && (E->NODE[lev][i]  & SBZ))
Instructions.c:	if ((E->NODE[lev][i]  & VBY) && (E->NODE[lev][i]  & SBY))
Instructions.c:  E->eco = E->ECO[E->mesh.levmax]; 
Instructions.c:  E->ien = E->IEN[E->mesh.levmax];
Instructions.c:  E->id = E->ID[E->mesh.levmax];
Instructions.c:  E->lm = E->LMD[E->mesh.levmax];
Instructions.c:  E->Vi = E->VI[E->mesh.levmax];
Instructions.c:  E->EVi = E->EVI[E->mesh.levmax];
Instructions.c:  E->node = E->NODE[E->mesh.levmax];
Instructions.c:  E->tw = E->TW[E->mesh.levmax];
Instructions.c:  E->Mass = E->MASS[E->mesh.levmax];
Instructions.c:  for (i=1;i<=E->mesh.nsd;i++)
Instructions.c:    E->X[i] = E->XX[E->mesh.levmax][i];
Instructions.c:{ if(E->control.verbose)
Instructions.c:{ if(E->control.verbose)
Instructions.c:    { fprintf(E->fp,"%s\n",string);
Instructions.c:      fflush(E->fp);
Instructions.c:  if (!E->control.restart)
Instructions.c:    for(i=1;i<=E->mesh.npno;i++)
Instructions.c:	    E->P[i]=0.0;
Instructions.c:    for(i=1;i<=E->mesh.nnov;i++)   {
Instructions.c:	E->V[1][i]=0.0;
Instructions.c:	E->V[2][i]=0.0;
Instructions.c:    if(E->mesh.dof==3)   {
Instructions.c: 	for(i=1;i<=E->mesh.nnov;i++)
Instructions.c:	    E->V[3][i]=0.0;
Nodal_mesh.c:  const int dims = E->mesh.nsd;
Nodal_mesh.c:  input_int("z_grid_layers",&(E->segment.zlayers),"1");
Nodal_mesh.c:  input_float_vector("zz",E->segment.zlayers,(E->segment.zzlayer));
Nodal_mesh.c:  input_int_vector("nz",E->segment.zlayers,(E->segment.nzlayer));
Nodal_mesh.c:  input_int("x_grid_layers",&(E->segment.xlayers),"1");
Nodal_mesh.c:  input_float_vector("xx",E->segment.xlayers,(E->segment.xxlayer));
Nodal_mesh.c:  input_int_vector("nx",E->segment.xlayers,(E->segment.nxlayer));
Nodal_mesh.c:     for(d=1;d<=E->mesh.nsd;d++) {
Nodal_mesh.c:       XX[d] = (float *)malloc((2+E->mesh.nnx[d])*sizeof(float)); 
Nodal_mesh.c:     dx[1] = E->mesh.layer[1]/(E->mesh.nnx[1]-1);
Nodal_mesh.c:     for(i=2;i<=E->mesh.nnx[1];i++)
Nodal_mesh.c:     dx[2] = E->mesh.layer[2]/(E->mesh.nnx[2]-1);
Nodal_mesh.c:     for(i=2;i<=E->mesh.nnx[2];i++)
Nodal_mesh.c:  for (j=1;j<E->segment.xlayers;j++)
Nodal_mesh.c:    dxx[j] = (E->segment.xxlayer[j]-E->segment.xxlayer[j-1])
Nodal_mesh.c:            /(E->segment.nxlayer[j]-E->segment.nxlayer[j-1]);
Nodal_mesh.c:  for(i=2;i<E->mesh.nnx[1];i++)   {
Nodal_mesh.c:    if (i<=E->segment.nxlayer[j])
Nodal_mesh.c:    if (i==E->segment.nxlayer[j])
Nodal_mesh.c:  for (j=1;j<E->segment.zlayers;j++)
Nodal_mesh.c:    dxx[j] = (E->segment.zzlayer[j]-E->segment.zzlayer[j-1])
Nodal_mesh.c:            /(E->segment.nzlayer[j]-E->segment.nzlayer[j-1]);
Nodal_mesh.c:  for(i=2;i<E->mesh.nnx[2];i++)   {
Nodal_mesh.c:    if (i<=E->segment.nzlayer[j])
Nodal_mesh.c:    if (i==E->segment.nzlayer[j])
Nodal_mesh.c:   for(d=1;d<=E->mesh.nsd;d++)
Nodal_mesh.c:     for(i=1;i<=E->mesh.nnx[d];i++)
Nodal_mesh.c:       E->XP[d][i] = XX[d][i]; 
Nodal_mesh.c:   for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Nodal_mesh.c:     nox=E->mesh.NOX[lev]; 
Nodal_mesh.c:     noy=E->mesh.NOY[lev];
Nodal_mesh.c:     noz=E->mesh.NOZ[lev];
Nodal_mesh.c:    if (E->control.NMULTIGRID||E->control.EMULTIGRID)
Nodal_mesh.c:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Nodal_mesh.c:           for(d=1;d<=E->mesh.nsd;d++)
Nodal_mesh.c:             E->XX[lev][d][node] = XX[d][(ijk[d]-1)*step+1]; 
Nodal_mesh.c:     for(d=1;d<=E->mesh.nsd;d++) {
Nodal_mesh.c:  if (E->control.verbose) 
Nodal_mesh.c:    for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Nodal_mesh.c:      fprintf(E->fp,"output_coordinates %d\n",lev);
Nodal_mesh.c:         for (i=1;i<=E->mesh.NNO[lev];i++)
Nodal_mesh.c:             fprintf(E->fp,"%d %g %g\n",i,E->XX[lev][1][i],E->XX[lev][2][i]);
Nodal_mesh.c:         for (i=1;i<=E->mesh.NNO[lev];i++)
Nodal_mesh.c:             fprintf(E->fp,"%d %g %g %g\n",i,E->XX[lev][1][i],E->XX[lev][2][i],E->XX[lev][3][i]);
Nodal_mesh.c:  for(node=1;node<=E->mesh.NNO[lev];node++)
Nodal_mesh.c:  for(element=1;element<=E->mesh.NEL[lev];element++) {
Nodal_mesh.c:      for(j=1;j<=enodes[E->mesh.nsd];j++)  {
Nodal_mesh.c:     	  node = E->IEN[lev][element].node[j];
Nodal_mesh.c:    	  PN[node] += P[element] * E->TW[lev][node] ; 
Nodal_mesh.c:  for(node=1;node<=E->mesh.NNO[lev];node++)
Nodal_mesh.c:  for(element=1;element<=E->mesh.NEL[lev];element++) {
Nodal_mesh.c:      for(j=1;j<=enodes[E->mesh.nsd];j++)  {
Nodal_mesh.c:     	  node = E->IEN[lev][element].node[j];
Nodal_mesh.c:    	  PN[node] += P[element] * E->TW[lev][node] ; 
Nodal_mesh.c:   for(p=1;p<=E->mesh.NEL[lev];p++)
Nodal_mesh.c:   weight=1.0/((double)enodes[E->mesh.nsd]) ;
Nodal_mesh.c:   for(p=1;p<=E->mesh.NEL[lev];p++)
Nodal_mesh.c:     for(j=1;j<=enodes[E->mesh.nsd];j++)
Nodal_mesh.c:       P[p] +=  PN[E->IEN[lev][p].node[j]] * weight;
Nodal_mesh.c:   const int nsd=E->mesh.nsd;
Nodal_mesh.c:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:          VE[(e-1)*vpts + i] += VN[E->IEN[lev][e].node[j]] *  E->N.vpt[GNVINDEX(j,i)];
Nodal_mesh.c:    const int nsd=E->mesh.nsd;
Nodal_mesh.c:    for(i=1;i<=E->mesh.NNO[lev];i++)
Nodal_mesh.c:    for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:        n = E->IEN[lev][e].node[j];
Nodal_mesh.c:          VN[n] += E->N.vpt[GNVINDEX(j,i)] * E->TW[lev][n] * VE[(e-1)*vpts + i];
Nodal_mesh.c:   const int nsd=E->mesh.nsd;
Nodal_mesh.c:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:          VE[(e-1)*vpts + i] += log(VN[E->IEN[lev][e].node[j]]) *  E->N.vpt[GNVINDEX(j,i)];
Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:  for(i=1;i<=E->mesh.NNO[lev];i++)
Nodal_mesh.c:  for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:      n = E->IEN[lev][e].node[j];
Nodal_mesh.c:	temp_visc += E->TW[lev][n] * log(E->N.vpt[GNVINDEX(j,i)] * VE[(e-1)*vpts + i]);
Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:   for(i=1;i<=E->mesh.NNO[lev];i++)
Nodal_mesh.c:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:       n = E->IEN[lev][e].node[j];
Nodal_mesh.c:         temp_visc += E->TW[lev][n] * E->N.vpt[GNVINDEX(j,i)] * VE[(e-1)*vpts + i];
Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:         temp_visc += E->N.vpt[GNVINDEX(j,i)]*VN[E->IEN[lev][e].node[j]];
Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:   for(i=1;i<=E->mesh.NEL[lev];i++)
Nodal_mesh.c:   for(e=1;e<=E->mesh.NEL[lev];e++)   {
Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:   for(e=1;e<=E->mesh.NEL[lev];e++)
Output.c:  const int nno = E->mesh.nno;
Output.c:  if (been_here==0 && E->control.restart==0) {
Output.c:    sprintf(output_file,"%s/coord.%d",E->control.data_file,file_number);
Output.c:    fprintf(fp0,"%6d %6d %.5e\n",E->mesh.nno,E->advection.timesteps,E->monitor.elapsed_time);
Output.c:    for (i=1;i<=E->mesh.nno;i++)
Output.c:      fprintf(fp0,"%6d %.3e %.3e %.5e %.5e %.5e %.5e %.4e\n",i,E->X[1][i],E->X[2][i],E->V[1][i],E->V[2][i],E->T[i],E->C[i],E->Vi[i]);
Output.c:  if ((E->advection.timesteps%(E->control.record_every)) == 0)   {
Output.c:    sprintf(output_file,"%s/temp_comp.%d",E->control.data_file,file_number);
Output.c:    fprintf(fp0,"%6d %6d %.5e\n",E->mesh.nno,E->advection.timesteps,E->monitor.elapsed_time);
Output.c:    if (E->control.composition) {
Output.c:      if ((E->advection.timesteps%(1*E->control.record_every)) == 0)  { 
Output.c:        for (i=1;i<=E->mesh.nno;i++)
Output.c:          fprintf(fp0,"%.4e %.4e %.4e %.4e %.4e %.4e\n",E->T[i],E->C[i],E->V[1][i],E->V[2][i],E->Vi[i],E->Cdot[i]);
Output.c:        for (i=1;i<=E->mesh.nel;i++)
Output.c:          fprintf(fp0,"%.4e\n",E->P[i]);
Output.c:        for (i=1;i<=E->mesh.nno;i++)
Output.c:          fprintf(fp0,"%.4e %.4e %.4e\n",E->T[i],E->C[i],E->Vi[i]);
Output.c:      if ((E->advection.timesteps%(E->control.record_every)) == 0)  { 
Output.c:        for (i=1;i<=E->mesh.nno;i++)
Output.c:          fprintf(fp0,"%.4e %.4e %.4e %.4e\n",E->T[i],E->V[1][i],E->V[2][i],E->Vi[i]);
Output.c:        for (i=1;i<=E->mesh.nel;i++)
Output.c:          fprintf(fp0,"%.4e\n",E->P[i]);
Output.c:        for (i=1;i<=E->mesh.nno;i++)
Output.c:          fprintf(fp0,"%.4e %.4e\n",E->T[i],E->Vi[i]);
Output.c: if (E->control.composition && (E->advection.timesteps%(1*E->control.record_every)) == 0)   {
Output.c:    sprintf(output_file,"%s/traces.%d",E->control.data_file,file_number);
Output.c:    fprintf(fp0,"%6d %6d %.5e\n",E->advection.markers,E->advection.timesteps,E->monitor.elapsed_time);
Output.c:    for (i=1;i<=E->advection.markers;i++)
Output.c:      fprintf(fp0,"%.5e %.5e %d %d\n",E->XMC[1][i],E->XMC[2][i],E->CElement[i],E->C12[i]);
Output.c:    for (i=1;i<=E->mesh.nel;i++)
Output.c:      fprintf(fp0,"%g\n",E->CE[i]);
Output.c:  if ((E->advection.timesteps%(E->control.record_every)) == 0)   {
Output.c:    for (i=1;i<=E->mesh.nox;i++)  {
Output.c:      j=i*E->mesh.noz;
Output.c:        surf += (E->slice.shflux[i]+E->slice.shflux[i-1])*0.5*
Output.c:           (E->X[1][j]-E->X[1][j-E->mesh.noz]);
Output.c:        botm += (E->slice.bhflux[i]+E->slice.bhflux[i-1])*0.5*
Output.c:           (E->X[1][j]-E->X[1][j-E->mesh.noz]);
Output.c:    surf = surf/E->X[1][E->mesh.nno];
Output.c:    botm = botm/E->X[1][E->mesh.nno];
Output.c:    for (i=1;i<=E->mesh.nno;i++)
Output.c:      SV[i] = sqrt(E->V[1][i]*E->V[1][i] + E->V[2][i]*E->V[2][i]);
Output.c:    return_horiz_ave(E,SV,E->Have.vrms);
Output.c:    return_horiz_ave(E,E->Vi,E->Have.Vi);
Output.c:    return_horiz_ave(E,E->T,E->Have.T);
Output.c:    return_horiz_ave(E,E->C,E->Have.Rho);
Output.c:    sprintf(output_file,"%s/topo_hf.%d",E->control.data_file,file_number);
Output.c:    fprintf(fp1,"%6d %6d %.5e %.5e %.5e %.5e\n",E->mesh.nno,E->advection.timesteps,E->monitor.elapsed_time,surf,botm,E->rad_heat.total);
Output.c:    for (i=1;i<=E->mesh.noz;i++)
Output.c:      fprintf(fp1,"%.4e %.5e %.5e %.5e %.5e\n",E->X[2][i],E->Have.T[i],E->Have.Rho[i],E->Have.Vi[i],E->Have.vrms[i]);
Output.c:    for (i=1;i<=E->mesh.nox;i++)  {
Output.c:      j=i*E->mesh.noz;
Output.c:      fprintf(fp1,"%.4e %.5e %.5e %.5e %.5e\n",E->X[1][j],E->slice.tpg[i],E->slice.tpgb[i],E->slice.shflux[i],E->slice.bhflux[i]);
Output.c:    eedot = (float *) malloc((2+E->mesh.nel)*sizeof(float));
Output.c:    eedot11 = (float *) malloc((2+E->mesh.nel)*sizeof(float));
Output.c:    eedot22 = (float *) malloc((2+E->mesh.nel)*sizeof(float));
Output.c:    eedot12 = (float *) malloc((2+E->mesh.nel)*sizeof(float));
Output.c:    edot = (float *) malloc((E->mesh.NEL[E->mesh.levmax]+2)*vpoints[E->mesh.nsd]*sizeof(float));
Output.c:    edot11 = (float *) malloc((E->mesh.NEL[E->mesh.levmax]+2)*vpoints[E->mesh.nsd]*sizeof(float));
Output.c:    edot22 = (float *) malloc((E->mesh.NEL[E->mesh.levmax]+2)*vpoints[E->mesh.nsd]*sizeof(float));
Output.c:    edot12 = (float *) malloc((E->mesh.NEL[E->mesh.levmax]+2)*vpoints[E->mesh.nsd]*sizeof(float));
Output.c:    for(i=1;i<=E->mesh.nel;i++) {
Output.c:        for(jj=1;jj<=vpoints[E->mesh.nsd];jj++)  {
Output.c:            edot[ (i-1)*vpoints[E->mesh.nsd]+jj ] = temp;
Output.c:            edot11[ (i-1)*vpoints[E->mesh.nsd]+jj ] = temp11;
Output.c:            edot22[ (i-1)*vpoints[E->mesh.nsd]+jj ] = temp22;
Output.c:            edot12[ (i-1)*vpoints[E->mesh.nsd]+jj ] = temp12;
Output.c:    v_to_nodes(E,edot,nedot,E->mesh.levmax);
Output.c:    v_to_nodes(E,edot11,nedot11,E->mesh.levmax);
Output.c:    v_to_nodes(E,edot22,nedot22,E->mesh.levmax);
Output.c:    v_to_nodes(E,edot12,nedot12,E->mesh.levmax);
Output.c:    sprintf(output_file,"%s/strainrate.%d",E->control.data_file,file_number); 
Output.c:  const int nno = E->mesh.nno;
Output.c:    sprintf(output_file,"%s/plume",E->control.data_file);
Output.c:    fprintf(fp0,"%6d %6d %.5e\n",E->mesh.nox,E->advection.timesteps,E->monitor.elapsed_time);
Output.c:    for (i=1;i<=E->mesh.nox;i++)  {
Output.c:      n1 = (i-1)*E->mesh.noz+E->control.PLUME;
Output.c:      n2 = (i-1)*E->mesh.noz+E->control.SLAB;
Output.c:      fprintf(fp0,"%.4e %.4e %.4e %.4e\n",E->T[n1],E->T[n2],E->V[1][n1],E->V[1][n2]);
Output.c:  E->ibm_dx.x1 = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Output.c:  E->ibm_dx.x2 = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Output.c:  E->ibm_dx.nox = E->mesh.nox;
Output.c:  E->ibm_dx.noz = E->mesh.noz;
Output.c:   for (i=1;i<=E->mesh.nno;i++)   {
Output.c:      E->ibm_dx.x1[i] = E->X[2][i] * sin(E->X[1][i]);
Output.c:      E->ibm_dx.x2[i] = E->X[2][i] * cos(E->X[1][i]);
Output.c:   sprintf(output_file,"%s/mv.%03d.dx",E->control.data_file,nframe);
Output.c:   for (i=1;i<=E->mesh.nno;i++)
Output.c:     fprintf(fp,"%g %g %g\n",E->ibm_dx.x1[i]+offset1,E->ibm_dx.x2[i],E->T[i]);
Output.c:   sprintf(output_file,"%s/nv.%03d.dx",E->control.data_file,nframe);
Output.c:   for (i=1;i<=E->mesh.nno;i++)
Output.c:     fprintf(fp,"%g %g %g\n",E->ibm_dx.x1[i]+offset2,E->ibm_dx.x2[i],E->C[i]);
Output.c:   sprintf(output_file,"%s/mv.%03d.general",E->control.data_file,nframe);
Output.c:   fprintf(fp,"grid = %2d x %2d\n",E->ibm_dx.nox,E->ibm_dx.noz);
Output.c:   sprintf(output_file,"%s/nv.%03d.general",E->control.data_file,nframe);
Output.c:   fprintf(fp,"grid = %2d x %2d\n",E->ibm_dx.nox,E->ibm_dx.noz);
Output.c:  const int nno = E->mesh.nno;
Output.c:  if (been_here==0 && E->control.restart==0) {
Output.c:    sprintf(output_file,"%s.velo",E->control.data_file);
Output.c:    E->filed[10]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    sprintf(output_file,"%s.topo_t",E->control.data_file);
Output.c:    E->filed[11]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    sprintf(output_file,"%s.topo_b",E->control.data_file);
Output.c:    E->filed[12]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    sprintf(output_file,"%s.visc",E->control.data_file);
Output.c:    E->filed[13]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    sprintf(output_file,"%s.fas670",E->control.data_file);
Output.c:    E->filed[14]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    sprintf(output_file,"%s.stress",E->control.data_file);
Output.c:    E->filed[9]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    ii = E->mesh.nsf;
Output.c:    size2 = (E->mesh.nel+1)*sizeof(float);
Output.c:  ii = E->mesh.nsf;
Output.c:  write(E->filed[10],SV,size2);
Output.c:  size2 = (E->mesh.nsf+1)*sizeof(float);
Output.c:  write(E->filed[11],E->slice.tpg,size2);
Output.c:  write(E->filed[12],E->slice.tpgb,size2);
Output.c:  size2 = (E->mesh.nel+1)*sizeof(float);
Output.c:  write(E->filed[13],EV,size2);
Output.c:  size2 = (E->mesh.nsf+1)*sizeof(float);
Output.c:  write(E->filed[14],E->Fas670_b,size2);
Output.c:  size2 = (2*E->mesh.nsf+1)*sizeof(float);
Output.c:  write(E->filed[9],E->stress,size2);
Output.c:  if (been_here==0 && E->control.restart==0) {
Output.c:    sprintf(output_file,"%s.temp",E->control.data_file);
Output.c:    E->filed[5]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    temp1 = (int *) malloc ((E->mesh.noy*6)*sizeof(int));
Output.c:    sprintf(output_file,"%s.mesh",E->control.data_file);
Output.c:    E->filed[1]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    sprintf(output_file,"%s.x",E->control.data_file);
Output.c:    E->filed[2]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    sprintf(output_file,"%s.z",E->control.data_file);
Output.c:    E->filed[3]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    sprintf(output_file,"%s.y",E->control.data_file);
Output.c:    E->filed[4]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:    size1 = (E->mesh.noy*6)*sizeof(int);
Output.c:    size2= (E->mesh.nno+1)*sizeof(float);
Output.c:    temp1[1] = E->mesh.nno;
Output.c:    temp1[5] = E->mesh.nsf;
Output.c:    temp1[6] = E->mesh.nel;
Output.c:        write(E->filed[1],temp1,size1);
Output.c:        write(E->filed[2],E->X[1],size2);
Output.c:        write(E->filed[3],E->X[2],size2);
Output.c:        write(E->filed[4],E->X[3],size2);
Output.c:    close(E->filed[1]);
Output.c:    close(E->filed[2]);
Output.c:    close(E->filed[3]);
Output.c:    close(E->filed[4]);
Output.c:    write(E->filed[5],E->T,size2);
Output.c:    const int vpts = vpoints[E->mesh.nsd];
Output.c:    const int nel = E->mesh.nel;
Output.c:    const int nno = E->mesh.nno;
Output.c:    const int ends = enodes[E->mesh.nsd];
Output.c:    sprintf(output_file,"%s/strainrate.%d",E->control.data_file,file_number);
Output.c:    fprintf(fp1,"%6d %6d %.5e\n",E->mesh.nno,E->advection.timesteps,E->monitor.elapsed_time);
Output.c:    v_to_nodes(E,eedot,nedot,E->mesh.levmax);
Output.c:    v_to_nodes(E,eedot11,nedot11,E->mesh.levmax);
Output.c:    v_to_nodes(E,eedot22,nedot22,E->mesh.levmax);
Output.c:    v_to_nodes(E,eedot12,nedot12,E->mesh.levmax);
Pan_problem_misc_functions.c:    sprintf(unique_name,"%06d.%s-%s",E->control.PID,comment,name);
Pan_problem_misc_functions.c:    slope = (E->data.therm_exp_factor-1.0);
Pan_problem_misc_functions.c:    H = (float *)malloc( (E->mesh.noz+1)*sizeof(float));
Pan_problem_misc_functions.c:    if (abs(E->control.Ra_670)>0.0 || abs(E->control.Ra_410)>0.0)   {
Pan_problem_misc_functions.c:      phase_change(E,E->Fas670,E->Fas670_b,E->Fas410,E->Fas410_b);
Pan_problem_misc_functions.c:      for(i=1;i<=E->mesh.nno;i++)
Pan_problem_misc_functions.c:        E->buoyancy[i] = -E->control.Ra_670 * E->Fas670[i] - E->control.Ra_410 * E->Fas410[i];
Pan_problem_misc_functions.c:      for(i=1;i<=E->mesh.nno;i++)
Pan_problem_misc_functions.c:        E->buoyancy[i] = 0.0;
Pan_problem_misc_functions.c:   for(i=1;i<=E->mesh.nno;i++)   {
Pan_problem_misc_functions.c:/*        E->buoyancy[i] = E->control.Ra_temp * E->T[i] * E->X[2][i]
Pan_problem_misc_functions.c:                       + E->control.Ra_comp * E->C[i] * E->X[2][i];
Pan_problem_misc_functions.c:       E->buoyancy[i] += E->control.Ra_temp * E->T[i] 
Pan_problem_misc_functions.c:                      * (slope*E->X[2][i] + 1.0)
Pan_problem_misc_functions.c:                      - E->control.Ra_comp * E->C[i]; 
Pan_problem_misc_functions.c:    remove_horiz_ave(E,E->buoyancy,H,0);
Pan_problem_misc_functions.c:    const int dims=E->mesh.nsd;
Pan_problem_misc_functions.c:    P=(float *)malloc((E->mesh.nno+1)*sizeof(float));
Pan_problem_misc_functions.c:     if(E->control.print_convergence) {   
Pan_problem_misc_functions.c:	for(i=1;i<=E->mesh.nno;i++) {
Pan_problem_misc_functions.c:		    if ((inside1 = cross2d(X[node1]-E->X[1][i],Z[node1]-E->X[2][i],X[node2]-E->X[1][i],Z[node2]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:			(inside4 = cross2d(X[node4]-E->X[1][i],Z[node4]-E->X[2][i],X[node1]-E->X[1][i],Z[node1]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:			(inside2 = cross2d(X[node2]-E->X[1][i],Z[node2]-E->X[2][i],X[node3]-E->X[1][i],Z[node3]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:			(inside3 = cross2d(X[node3]-E->X[1][i],Z[node3]-E->X[2][i],X[node4]-E->X[1][i],Z[node4]-E->X[2][i],3)) <= 0.0) {
Pan_problem_misc_functions.c:		    if ((inside1 = cross2d(X[node1]-E->X[1][i],Z[node1]-E->X[2][i],X[node2]-E->X[1][i],Z[node2]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:			(inside4 = cross2d(X[node4]-E->X[1][i],Z[node4]-E->X[2][i],X[node1]-E->X[1][i],Z[node1]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:			(inside2 = cross2d(X[node2]-E->X[1][i],Z[node2]-E->X[2][i],X[node3]-E->X[1][i],Z[node3]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:			(inside3 = cross2d(X[node3]-E->X[1][i],Z[node3]-E->X[2][i],X[node4]-E->X[1][i],Z[node4]-E->X[2][i],3)) <= 0.0) {
Pan_problem_misc_functions.c:		distance1 = ((X[node1]-E->X[1][i])*(X[node1]-E->X[1][i])+(Z[node1]-E->X[2][i])*(Z[node1]-E->X[2][i]));
Pan_problem_misc_functions.c:		distance2 = ((X[node2]-E->X[1][i])*(X[node2]-E->X[1][i])+(Z[node2]-E->X[2][i])*(Z[node2]-E->X[2][i]));
Pan_problem_misc_functions.c:		distance3 = ((X[node3]-E->X[1][i])*(X[node3]-E->X[1][i])+(Z[node3]-E->X[2][i])*(Z[node3]-E->X[2][i]));
Pan_problem_misc_functions.c:		distance4 = ((X[node4]-E->X[1][i])*(X[node4]-E->X[1][i])+(Z[node4]-E->X[2][i])*(Z[node4]-E->X[2][i]));
Pan_problem_misc_functions.c:   	vcopy(TT,T,1,E->mesh.nno); }
Pan_problem_misc_functions.c:    if(E->control.print_convergence)
Pan_problem_misc_functions.c:	fprintf(E->fp,"Warning: unable to interpolate old  data to %d nodes in the new mesh\n",not_found);
Pan_problem_misc_functions.c:	p_to_centres(E,TT,P,E->mesh.levmax); /* if interpolated, apply slight smoothing */
Pan_problem_misc_functions.c:	p_to_nodes(E,P,TT,E->mesh.levmax);
Pan_problem_misc_functions.c:    for(node=1;node<=E->mesh.nno;node++) {
Pan_problem_misc_functions.c:	x1=E->X[1][node];
Pan_problem_misc_functions.c:	z1=E->X[2][node];
Pan_problem_misc_functions.c:	y1=(E->mesh.nsd!=3) ? 0.0 : E->X[3][node];
Pan_problem_misc_functions.c:	    in3=(3!=E->mesh.nsd || y1 >= RECT->y1[number] && y1 <= RECT->y2[number]);
Pan_problem_misc_functions.c:		fprintf(E->fp,"RECTANGLE: %d can't work out how to combine new/old fields\n",number);
Pan_problem_misc_functions.c:    for(node=1;node<=E->mesh.nno;node++) {
Pan_problem_misc_functions.c:	x1=E->X[1][node];
Pan_problem_misc_functions.c:	z1=E->X[2][node];
Pan_problem_misc_functions.c:	y1=(E->mesh.nsd!=3) ? 0.0 : E->X[3][node];
Pan_problem_misc_functions.c:		((E->mesh.nsd != 3) ? 0.0 : (y1-CIRC->y[number])*(y1-CIRC->y[number]));
Pan_problem_misc_functions.c:		fprintf(E->fp,"CIRCLE: %d can't work out how to combine new/old fields\n",number);
Pan_problem_misc_functions.c:    for(node=1;node<=E->mesh.nno;node++) {
Pan_problem_misc_functions.c:	x1=E->X[1][node];
Pan_problem_misc_functions.c:	z1=E->X[2][node];
Pan_problem_misc_functions.c:	y1=(E->mesh.nsd!=3) ? 0.0 : E->X[3][node];
Pan_problem_misc_functions.c:	    in3=(3!=E->mesh.nsd || y1 >= HARM->y1[number] && y1 <= HARM->y2[number]);
Pan_problem_misc_functions.c:		    fprintf(E->fp,"POLYNOMIAL: %d can't work out how to combine new/old fields\n",number);
Phase_change.c:      E->control.Ra_670 = E->control.Ra_670*E->control.Ra_temp
Phase_change.c:              /(E->data.density*E->data.therm_exp*E->data.ref_temperature);
Phase_change.c:      E->control.Ra_410 = E->control.Ra_410*E->control.Ra_temp
Phase_change.c:              /(E->data.density*E->data.therm_exp*E->data.ref_temperature);
Phase_change.c:      E->control.clapeyron670 = E->control.clapeyron670*E->data.ref_temperature/
Phase_change.c:                          (E->data.density*E->data.grav_acc*E->data.layer_meter);
Phase_change.c:      E->control.clapeyron410 = E->control.clapeyron410*E->data.ref_temperature/
Phase_change.c:                          (E->data.density*E->data.grav_acc*E->data.layer_meter);
Phase_change.c:      E->control.width670 = E->data.layer_meter/E->control.width670;
Phase_change.c:      E->control.width410 = E->data.layer_meter/E->control.width410;
Phase_change.c:      E->control.transT670 = E->control.transT670/E->data.ref_temperature;
Phase_change.c:      E->control.transT410 = E->control.transT410/E->data.ref_temperature;
Phase_change.c:fprintf(E->fp,"Rab410 670=%g %g Clap410 670=%g %g Di=%g %g \n",E->control.Ra_410,E->control.Ra_670,E->control.clapeyron410,E->control.clapeyron670,E->data.disptn_number,E->data.ref_viscosity);
Phase_change.c:  for(i=1;i<=E->mesh.nno;i++)  {
Phase_change.c:    e_pressure = E->viscosity.zlm - E->X[2][i] -
Phase_change.c:            E->control.clapeyron670*(E->T[i]-E->control.transT670);
Phase_change.c:    Bb[i] = pt5*(one+tanh(E->control.width670*e_pressure));
Phase_change.c:  for(i=1;i<=E->mesh.nno;i++)  {
Phase_change.c:    e_pressure = E->viscosity.z410 - E->X[2][i] -
Phase_change.c:            E->control.clapeyron410*(E->T[i]-E->control.transT410);
Phase_change.c:    Bt[i] = pt5*(one+tanh(E->control.width410*e_pressure));
Phase_change.c:if (E->advection.timesteps%E->control.record_every == 0)   {
Phase_change.c:    for (j=1;j<=E->mesh.nox;j++)  {
Phase_change.c:      for (i=1;i<E->mesh.noz;i++)   {
Phase_change.c:        n = (j-1)*E->mesh.noz + i;
Phase_change.c:          Bb_b[j]=(E->X[2][n+1]-E->X[2][n])*(pt5-Bb[n])/(Bb[n+1]-Bb[n])+E->X[2][n];
Phase_change.c:   for (j=1;j<=E->mesh.nox;j++)  {
Phase_change.c:      for (i=1;i<E->mesh.noz;i++)   {
Phase_change.c:        n = (j-1)*E->mesh.noz + i;
Phase_change.c:          Bt_b[j]=(E->X[2][n+1]-E->X[2][n])*(pt5-Bt[n])/(Bt[n+1]-Bt[n])+E->X[2][n];
Phase_change.c:  sprintf(output_file,"%s/fas.%d",E->control.data_file,E->advection.timesteps);
Phase_change.c:  for (j=1;j<=E->mesh.nox;j++)
Phase_change.c://    fprintf(fp1,"%.4e %.5e %.5e\n",E->X[1][j*E->mesh.noz],Bt_b[j],Bb_b[j]);
Phase_change.c:      fprintf(fp1,"%.4e %.5e %.5e %.5e %.5e\n",E->X[1][j*E->mesh.noz],Bt_b[j],Bb_b[j],Bt[i],Bb[i]);
Process_buoyancy.c:    if ( ((ii % E->control.record_every) == 0))    {
Process_buoyancy.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Process_buoyancy.c:    const int nno=E->mesh.nno;
Process_buoyancy.c:    const int lev = E->mesh.levmax;
Process_buoyancy.c:    for(e=1;e<=E->mesh.nel;e++) {
Process_buoyancy.c:      get_global_shape_fn(E,e,&GN,&GNx,&dOmega,2,E->mesh.levmax);
Process_buoyancy.c:          VZ[j] = E->V[2][E->ien[e].node[j]];
Process_buoyancy.c:          u[i] += VZ[j]*E->N.ppt[GNPINDEX(j,i)];
Process_buoyancy.c:          T[i] += E->T[E->ien[e].node[j]]*E->N.ppt[GNPINDEX(j,i)];
Process_buoyancy.c:          dTdz[i] += -E->T[E->ien[e].node[j]]*GNx.ppt[GNPXINDEX(1,j,i)];
Process_buoyancy.c:        flux[E->ien[e].node[j]] += uT*E->TWW[E->mesh.levmax][e].node[j];
Process_buoyancy.c:      flux[i] = flux[i]*E->Mass[i];
Process_buoyancy.c:    for(i=1;i<=E->mesh.nsf;i++)   {
Process_buoyancy.c:      E->slice.shflux[i] = 2*flux[E->surf_node[i]]
Process_buoyancy.c:                           - flux[E->surf_node[i]-1];
Process_buoyancy.c:      E->slice.bhflux[i] = 2*flux[E->surf_node[i]-E->mesh.noz+1]
Process_buoyancy.c:                           - flux[E->surf_node[i]-E->mesh.noz+2];
Process_velocity.c: 	   E->monitor.length_scale = E->data.layer_km/E->mesh.layer[2]; /* km */
Process_velocity.c:           temp= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Process_velocity.c:           sprintf(output_file,"%s/vrms_time",E->control.data_file);
Process_velocity.c:        for (i=1;i<=E->mesh.nno;i++)
Process_velocity.c:          temp[i] = E->V[1][i]*E->V[1][i]+E->V[2][i]*E->V[2][i];
Process_velocity.c:        cc1 = return_bulk_value(E,E->C,1);
Process_velocity.c:        fprintf(fp,"%g %g %g\n",E->monitor.elapsed_time,vrms,cc1);
Process_velocity.c:    if ((ii % E->control.record_every) == 0)     {
Process_velocity.c:      get_STD_topo(E,E->slice.tpg,E->slice.tpgb,ii); 
Process_velocity.c:    if (((5*ii) % E->control.record_every) == 0)     {
Process_velocity.c:  const int dims=E->mesh.nsd;
Process_velocity.c:  const int nno=E->mesh.nno;
Process_velocity.c:  lev = E->mesh.levmax;
Process_velocity.c:    if ((node-1)%E->mesh.noz==0)   {
Process_velocity.c:      i = (node-1)/E->mesh.noz + 1;
Process_velocity.c:        SV[(i-1)*2+1] = E->V[1][node];
Process_velocity.c:        SV[(i-1)*2+2] = E->V[3][node];
Process_velocity.c:  const int nel=E->mesh.nel;
Process_velocity.c:  const int vpts=vpoints[E->mesh.nsd];
Process_velocity.c:  lev = E->mesh.levmax;
Process_velocity.c:      EV[el] +=  E->EVI[lev][(el-1)*vpts+j];
Process_velocity.c:  stride = E->mesh.nsf*6;
Process_velocity.c:  for (node=1;node<=E->mesh.nno;node++)
Process_velocity.c:     if ( ((node-1)%E->mesh.noz)==0 )  {
Process_velocity.c:        i = (node-1)/E->mesh.noz+1;
Process_velocity.c:        E->stress[(i-1)*6+1] = SXX[node];
Process_velocity.c:        E->stress[(i-1)*6+2] = SZZ[node];
Process_velocity.c:        E->stress[(i-1)*6+3] = SYY[node];
Process_velocity.c:        E->stress[(i-1)*6+4] = SXY[node];
Process_velocity.c:        E->stress[(i-1)*6+5] = SXZ[node];
Process_velocity.c:        E->stress[(i-1)*6+6] = SZY[node];
Process_velocity.c:     else if ( ((node-2)%E->mesh.noz)==0 )  {
Process_velocity.c:        i = (node-2)/E->mesh.noz+1;
Process_velocity.c:        E->stress[stride+(i-1)*6+1] = SXX[node];
Process_velocity.c:        E->stress[stride+(i-1)*6+2] = SZZ[node];
Process_velocity.c:        E->stress[stride+(i-1)*6+3] = SYY[node];
Process_velocity.c:        E->stress[stride+(i-1)*6+4] = SXY[node];
Process_velocity.c:        E->stress[stride+(i-1)*6+5] = SXZ[node];
Process_velocity.c:        E->stress[stride+(i-1)*6+6] = SZY[node];
Shape_functions.c:    { E->N.vpt[i] = 0.0; 
Shape_functions.c:      E->Nx.vpt[i] = 0.0;
Shape_functions.c:      E->Nx.vpt[GNVI+i] = 0.0;
Shape_functions.c:      E->Nx.vpt[2*GNVI+i] = 0.0; 
Shape_functions.c:    { E->N.ppt[i] = 0.0; 
Shape_functions.c:      E->Nx.ppt[i] = 0.0;
Shape_functions.c:      E->Nx.ppt[GNPI+i] = 0.0;
Shape_functions.c:      E->Nx.ppt[2*GNPI+i] = 0.0; 
Shape_functions.c:    { E->M.vpt[i] = 0.0; 
Shape_functions.c:      E->Mx.vpt[i] = 0.0;
Shape_functions.c:      E->Mx.vpt[GN1VI+i] = 0.0;
Shape_functions.c:    { E->M.ppt[i] = 0.0; 
Shape_functions.c:      E->Mx.ppt[i] = 0.0;
Shape_functions.c:      E->Mx.ppt[GN1PI+i] = 0.0;
Shape_functions.c:    { E->L.vpt[i] = 0.0; 
Shape_functions.c:      E->Lx.vpt[i] = 0.0;
Shape_functions.c:      E->Lx.vpt[GN1VI+i] = 0.0;
Shape_functions.c:  for(i=1;i<=enodes[E->mesh.nsd];i++)   {
Shape_functions.c:      for(j=1;j<=vpoints[E->mesh.nsd];j++)  { 
Shape_functions.c:	  E->N.vpt[GNVINDEX(i,j)] = 1.0;
Shape_functions.c:	  for(d=1;d<=E->mesh.nsd;d++)  {
Shape_functions.c:	      E->N.vpt[GNVINDEX(i,j)] *=  
Shape_functions.c:	  for(dd=1;dd<=E->mesh.nsd;dd++) {
Shape_functions.c:	      E->Nx.vpt[GNVXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],g_point[j].x[dd-1]);
Shape_functions.c:	      for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:		      E->Nx.vpt[GNVXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],g_point[j].x[d-1]);
Shape_functions.c:      for(j=1;j<=ppoints[E->mesh.nsd];j++)  {
Shape_functions.c:	  E->N.ppt[GNPINDEX(i,j)] = 1.0;
Shape_functions.c:	  for(d=1;d<=E->mesh.nsd;d++){
Shape_functions.c:	      E->N.ppt[GNPINDEX(i,j)] *=  
Shape_functions.c:	  for(dd=1;dd<=E->mesh.nsd;dd++) {
Shape_functions.c:	      E->Nx.ppt[GNPXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],p_point[j].x[dd-1]);
Shape_functions.c:	      for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:		      E->Nx.ppt[GNPXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],p_point[j].x[d-1]); 
Shape_functions.c:  for(j=1;j<=onedvpoints[E->mesh.nsd];j++)
Shape_functions.c:    { remapj = ccc[E->mesh.nsd-2][j];
Shape_functions.c:      for(k=1;k<=onedvpoints[E->mesh.nsd];k++)     
Shape_functions.c:	{ remapk = ccc[E->mesh.nsd-2][k];
Shape_functions.c:	  E->M.vpt[GMVINDEX(j,k)] = 1.0;
Shape_functions.c:	  E->L.vpt[GMVINDEX(j,k)] = 1.0;
Shape_functions.c:	  for(d=1;d<=E->mesh.nsd-1;d++) {
Shape_functions.c:	    E->M.vpt[GMVINDEX(j,k)] *= lpoly(cc[d-1][remapj],g_1d[k].x[d-1]);
Shape_functions.c:	    E->L.vpt[GMVINDEX(j,k)] *= lpoly(cc[d-1][remapj],l_1d[k].x[d-1]);
Shape_functions.c:	  for(dd=1;dd<=E->mesh.nsd-1;dd++) {
Shape_functions.c:	      E->Mx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(cc[dd-1][remapj],g_1d[k].x[dd-1]); 
Shape_functions.c:	      E->Lx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(cc[dd-1][remapj],l_1d[k].x[dd-1]); 
Shape_functions.c:	      for(d=1;d<=E->mesh.nsd-1;d++)
Shape_functions.c:		  E->Mx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(cc[d-1][remapj],g_1d[k].x[d-1]); 
Shape_functions.c:		  E->Lx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(cc[d-1][remapj],l_1d[k].x[d-1]); 
Size_does_matter.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Size_does_matter.c:			dxda[d][e] += E->XX[lv][e][E->IEN[lv][el].node[i]] * E->Nx.vpt[GNVXINDEX(d-1,i,k)];   /* This is Shijie's change (d<->e) */
Size_does_matter.c:	      jacobian = determinant(dxda,E->mesh.nsd);  
Size_does_matter.c:			GNx->vpt[GNVXINDEX(d-1,j,k)] += E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];   /* switch e and d for cof  -- Shijie's  */
Size_does_matter.c:			    dxda[d][e] += E->XX[lv][e][E->IEN[lv][el].node[i]] * E->Nx.ppt[GNPXINDEX(d-1,i,k)];
Size_does_matter.c:	          jacobian = determinant(dxda,E->mesh.nsd);     
Size_does_matter.c:		        cof[d][e]=cofactor(dxda,d,e,E->mesh.nsd); 
Size_does_matter.c:		           GNx->ppt[GNPXINDEX(d-1,j,k)] += E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d]; 
Size_does_matter.c:	for(dirn=1;dirn<=E->mesh.nsd;dirn++)     {
Size_does_matter.c:	    for(k=1;k<=onedvpoints[E->mesh.nsd];k++)  { /* all of the vpoints*/
Size_does_matter.c:	        for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:		  for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:		   for(i=1;i<=onedvpoints[E->mesh.nsd];i++)      /* nodes */
Size_does_matter.c:		     for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:		       for(e=1;e<=E->mesh.nsd-1;e++)    {
Size_does_matter.c:		          dxda[d][e] += E->X[collapsed_dirn[e-1]][E->ien[el].node[node[i]]]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];      
Size_does_matter.c:		   for(i=1;i<=onedvpoints[E->mesh.nsd];i++)      /* nodes */
Size_does_matter.c:		     for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:		       for(e=1;e<=E->mesh.nsd-1;e++)    {
Size_does_matter.c:		          dxda[d][e] += E->X[collapsed_dirn[e-1]][E->ien[el].node[node[i]]]*E->Lx.vpt[GMVXINDEX(d-1,i,k)];      
Size_does_matter.c:		jacobian = determinant(dxda,E->mesh.nsd-1); 
Size_does_matter.c:		dGammax->vpt[GMVGAMMA(dirn-1+E->mesh.nsd*locn,k)] = jacobian;
Size_does_matter.c:  const int ppts=ppoints[E->mesh.nsd];
Size_does_matter.c:  const int vpts=vpoints[E->mesh.nsd];
Size_does_matter.c:  for (lv=E->mesh.levmin;lv<=E->mesh.levmax;lv++)   {
Size_does_matter.c:    for(node=1;node<=E->mesh.NNO[lv];node++)
Size_does_matter.c:      E->MASS[lv][node] = 0.0;
Size_does_matter.c:    for(e=1;e<=E->mesh.NEL[lv];e++)  {
Size_does_matter.c:      for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:        n[node] = E->IEN[lv][e].node[node];
Size_does_matter.c:      for(i=1;i<=E->mesh.nsd;i++)  {
Size_does_matter.c:        for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:	      centre[i] += E->XX[lv][i][E->IEN[lv][e].node[node]];
Size_does_matter.c:    	E->ECO[lv][e].centre[i] = centre[i]/enodes[E->mesh.nsd];
Size_does_matter.c:      if (3==E->mesh.nsd)   {
Size_does_matter.c:        dx1 = 0.25*(E->XX[lv][1][n[3]]+E->XX[lv][1][n[4]]
Size_does_matter.c:                   +E->XX[lv][1][n[7]]+E->XX[lv][1][n[8]]
Size_does_matter.c:                   -E->XX[lv][1][n[1]]-E->XX[lv][1][n[2]]
Size_does_matter.c:                   -E->XX[lv][1][n[5]]-E->XX[lv][1][n[6]]);
Size_does_matter.c:        dx2 = 0.25*(E->XX[lv][2][n[3]]+E->XX[lv][2][n[4]]
Size_does_matter.c:                   +E->XX[lv][2][n[7]]+E->XX[lv][2][n[8]]
Size_does_matter.c:                   -E->XX[lv][2][n[1]]-E->XX[lv][2][n[2]]
Size_does_matter.c:                   -E->XX[lv][2][n[5]]-E->XX[lv][3][n[6]]);
Size_does_matter.c:        dx3 = 0.25*(E->XX[lv][3][n[3]]+E->XX[lv][3][n[4]]
Size_does_matter.c:                   +E->XX[lv][3][n[7]]+E->XX[lv][3][n[8]]
Size_does_matter.c:                   -E->XX[lv][3][n[1]]-E->XX[lv][3][n[2]]
Size_does_matter.c:                   -E->XX[lv][3][n[5]]-E->XX[lv][3][n[6]]);
Size_does_matter.c:        E->ECO[lv][e].size[1] = sqrt(dx1*dx1 + dx2*dx2 + dx3*dx3);
Size_does_matter.c:        dx1 = 0.25*(E->XX[lv][1][n[2]]+E->XX[lv][1][n[3]]
Size_does_matter.c:                   +E->XX[lv][1][n[6]]+E->XX[lv][1][n[7]]
Size_does_matter.c:                   -E->XX[lv][1][n[1]]-E->XX[lv][1][n[4]]
Size_does_matter.c:                   -E->XX[lv][1][n[5]]-E->XX[lv][1][n[8]]);
Size_does_matter.c:        dx2 = 0.25*(E->XX[lv][2][n[2]]+E->XX[lv][2][n[3]]
Size_does_matter.c:                   +E->XX[lv][2][n[6]]+E->XX[lv][2][n[7]]
Size_does_matter.c:                   -E->XX[lv][2][n[1]]-E->XX[lv][2][n[4]]
Size_does_matter.c:                   -E->XX[lv][2][n[5]]-E->XX[lv][3][n[8]]);
Size_does_matter.c:        dx3 = 0.25*(E->XX[lv][3][n[2]]+E->XX[lv][3][n[3]]
Size_does_matter.c:                   +E->XX[lv][3][n[6]]+E->XX[lv][3][n[7]]
Size_does_matter.c:                   -E->XX[lv][3][n[1]]-E->XX[lv][3][n[4]]
Size_does_matter.c:                   -E->XX[lv][3][n[5]]-E->XX[lv][3][n[8]]);
Size_does_matter.c:        E->ECO[lv][e].size[2] = sqrt(dx1*dx1 + dx2*dx2 + dx3*dx3);
Size_does_matter.c:        dx1 = 0.25*(E->XX[lv][1][n[5]]+E->XX[lv][1][n[6]]
Size_does_matter.c:                   +E->XX[lv][1][n[7]]+E->XX[lv][1][n[8]]
Size_does_matter.c:                   -E->XX[lv][1][n[1]]-E->XX[lv][1][n[2]]
Size_does_matter.c:                   -E->XX[lv][1][n[3]]-E->XX[lv][1][n[4]]);
Size_does_matter.c:        dx2 = 0.25*(E->XX[lv][2][n[5]]+E->XX[lv][2][n[6]]
Size_does_matter.c:                   +E->XX[lv][2][n[7]]+E->XX[lv][2][n[8]]
Size_does_matter.c:                   -E->XX[lv][2][n[1]]-E->XX[lv][2][n[2]]
Size_does_matter.c:                   -E->XX[lv][2][n[3]]-E->XX[lv][3][n[4]]);
Size_does_matter.c:        dx3 = 0.25*(E->XX[lv][3][n[5]]+E->XX[lv][3][n[6]]
Size_does_matter.c:                   +E->XX[lv][3][n[7]]+E->XX[lv][3][n[8]]
Size_does_matter.c:                   -E->XX[lv][3][n[1]]-E->XX[lv][3][n[2]]
Size_does_matter.c:                   -E->XX[lv][3][n[3]]-E->XX[lv][3][n[4]]);
Size_does_matter.c:        E->ECO[lv][e].size[3] = sqrt(dx1*dx1 + dx2*dx2 + dx3*dx3);
Size_does_matter.c:      else if (2==E->mesh.nsd)   {
Size_does_matter.c:        dx1 = 0.5*(E->XX[lv][1][n[3]]+E->XX[lv][1][n[4]]
Size_does_matter.c:                  -E->XX[lv][1][n[1]]-E->XX[lv][1][n[2]]);
Size_does_matter.c:        dx2 = 0.5*(E->XX[lv][2][n[3]]+E->XX[lv][2][n[4]]
Size_does_matter.c:                  -E->XX[lv][2][n[1]]-E->XX[lv][2][n[2]]);
Size_does_matter.c:        E->ECO[lv][e].size[1] = sqrt(dx1*dx1 + dx2*dx2);
Size_does_matter.c:        dx1 = 0.5*(E->XX[lv][1][n[2]]+E->XX[lv][1][n[3]]
Size_does_matter.c:                  -E->XX[lv][1][n[1]]-E->XX[lv][1][n[4]]);
Size_does_matter.c:        dx2 = 0.5*(E->XX[lv][2][n[2]]+E->XX[lv][2][n[3]]
Size_does_matter.c:                  -E->XX[lv][2][n[1]]-E->XX[lv][2][n[4]]);
Size_does_matter.c:        E->ECO[lv][e].size[2] = sqrt(dx1*dx1 + dx2*dx2);
Size_does_matter.c:        area += g_point[nint].weight[E->mesh.nsd-1] * dOmega.vpt[nint];
Size_does_matter.c:      E->ECO[lv][e].area = area;
Size_does_matter.c:      for(node=1;node<=enodes[E->mesh.nsd];node++)  {
Size_does_matter.c:          temp[node] += dOmega.vpt[nint]*g_point[nint].weight[E->mesh.nsd-1]
Size_does_matter.c:                       *E->N.vpt[GNVINDEX(node,nint)];       /* int Na dV */
Size_does_matter.c:      for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:         E->MASS[lv][E->IEN[lv][e].node[node]] += temp[node];
Size_does_matter.c:        for(node=1;node<=enodes[E->mesh.nsd];node++)  {
Size_does_matter.c:           E->TWW[lv][e].node[node] = temp[node];
Size_does_matter.c:    for(node=1;node<=E->mesh.NNO[lv];node++)  {
Size_does_matter.c:      E->MASS[lv][node] = 1.0/E->MASS[lv][node];
Solver_conj_grad.c:  E->build_forcing_term = assemble_forces_iterative;
Solver_conj_grad.c:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Solver_conj_grad.c:  E->solver_allocate_vars = cg_allocate_vars;
Solver_conj_grad.c:  strip_bcs_from_residual(E,E->F,E->mesh.levmax);
Solver_multigrid.c:  E->solver_allocate_vars = mg_allocate_vars;
Solver_multigrid.c:  E->build_forcing_term = assemble_forces_iterative;
Solver_multigrid.c:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Solver_multigrid.c:  E->control.mg_cycle = 1;
Solver_multigrid.c:    const int neq_minus=E->mesh.NEQ[start_lev-1];
Solver_multigrid.c:    const int nno_minus=E->mesh.NNO[start_lev-1];
Solver_multigrid.c:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:	    e1 = E->EL[sl_minus][el].sub[1];
Solver_multigrid.c:            node1=E->IEN[start_lev][e1].node[7];
Solver_multigrid.c:		node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[1]] += AU[E->ID[start_lev][node1].doff[1]]; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[2]] += AU[E->ID[start_lev][node1].doff[2]]; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[3]] += AU[E->ID[start_lev][node1].doff[3]]; 
Solver_multigrid.c:	    e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:              node1 = E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:              average1 += AU[E->ID[start_lev][node1].doff[1]];
Solver_multigrid.c:              average2 += AU[E->ID[start_lev][node1].doff[2]];
Solver_multigrid.c:	    node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:	    AD[E->ID[sl_minus][node].doff[1]] += average1; 
Solver_multigrid.c:	    AD[E->ID[sl_minus][node].doff[2]] += average2; 
Solver_multigrid.c:    const int neq_minus=E->mesh.NEQ[start_lev-1];
Solver_multigrid.c:    const int nno_minus=E->mesh.NNO[start_lev-1];
Solver_multigrid.c:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:	    e1 = E->EL[sl_minus][el].sub[1];
Solver_multigrid.c:            node1=E->IEN[start_lev][e1].node[7];
Solver_multigrid.c:		node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[1]] += AU[E->ID[start_lev][node1].doff[1]]; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[2]] += AU[E->ID[start_lev][node1].doff[2]]; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[3]] += AU[E->ID[start_lev][node1].doff[3]]; 
Solver_multigrid.c:	    e1 = E->EL[sl_minus][el].sub[1];
Solver_multigrid.c:            node1=E->IEN[start_lev][e1].node[3];
Solver_multigrid.c:		node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[1]] += AU[E->ID[start_lev][node1].doff[1]]; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[2]] += AU[E->ID[start_lev][node1].doff[2]]; 
Solver_multigrid.c:    const int neq_minus=E->mesh.NEQ[start_lev-1];
Solver_multigrid.c:    const int nno_minus=E->mesh.NNO[start_lev-1];
Solver_multigrid.c:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:		e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:		    node=E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:		    average1 += AU[E->ID[start_lev][node].doff[1]];
Solver_multigrid.c:		    average2 += AU[E->ID[start_lev][node].doff[2]];
Solver_multigrid.c:		    average3 += AU[E->ID[start_lev][node].doff[3]];
Solver_multigrid.c:		node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[1]] += E->TWW[sl_minus][el].node[i] * average1; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[2]] += E->TWW[sl_minus][el].node[i] * average2; 
Solver_multigrid.c:	 	AD[E->ID[sl_minus][node].doff[3]] += E->TWW[sl_minus][el].node[i] * average3; 
Solver_multigrid.c:		e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:		    node =E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:		    average1 += AU[E->ID[start_lev][node].doff[1]];
Solver_multigrid.c:		    average2 += AU[E->ID[start_lev][node].doff[2]];
Solver_multigrid.c:		node=E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[1]] += E->TWW[sl_minus][el].node[i] * average1; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[2]] += E->TWW[sl_minus][el].node[i] * average2; 
Solver_multigrid.c:       AD[E->ID[sl_minus][i].doff[1]] = AD[E->ID[sl_minus][i].doff[1]] * E->MASS[sl_minus][i];
Solver_multigrid.c:       AD[E->ID[sl_minus][i].doff[2]] = AD[E->ID[sl_minus][i].doff[2]] * E->MASS[sl_minus][i];
Solver_multigrid.c:       AD[E->ID[sl_minus][i].doff[3]] = AD[E->ID[sl_minus][i].doff[3]] * E->MASS[sl_minus][i];
Solver_multigrid.c:       AD[E->ID[sl_minus][i].doff[1]] = AD[E->ID[sl_minus][i].doff[1]] * E->MASS[sl_minus][i];
Solver_multigrid.c:       AD[E->ID[sl_minus][i].doff[2]] = AD[E->ID[sl_minus][i].doff[2]] * E->MASS[sl_minus][i];
Solver_multigrid.c:    const int neq_minus=E->mesh.NEQ[start_lev-1];
Solver_multigrid.c:    const int nno_minus=E->mesh.NNO[start_lev-1];
Solver_multigrid.c:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:		e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:		    node=E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:		    average1 += AU[E->ID[start_lev][node].doff[1]];
Solver_multigrid.c:		    average2 += AU[E->ID[start_lev][node].doff[2]];
Solver_multigrid.c:		    average3 += AU[E->ID[start_lev][node].doff[3]];
Solver_multigrid.c:		node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:		w=weight * E->TWW[sl_minus][el].node[i]; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[1]] += w * average1; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[2]] += w * average2; 
Solver_multigrid.c:	 	AD[E->ID[sl_minus][node].doff[3]] += w * average3; 
Solver_multigrid.c:		e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:		    node =E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:		    average1 += AU[E->ID[start_lev][node].doff[1]];
Solver_multigrid.c:		    average2 += AU[E->ID[start_lev][node].doff[2]];
Solver_multigrid.c:		node=E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:		w=weight * E->TWW[sl_minus][el].node[i]; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[1]] += w * average1; 
Solver_multigrid.c:		AD[E->ID[sl_minus][node].doff[2]] += w * average2; 
Solver_multigrid.c:       AD[E->ID[sl_minus][i].doff[1]] = AD[E->ID[sl_minus][i].doff[1]] * E->MASS[sl_minus][i] * amplifier;
Solver_multigrid.c:       AD[E->ID[sl_minus][i].doff[2]] = AD[E->ID[sl_minus][i].doff[2]] * E->MASS[sl_minus][i] * amplifier;
Solver_multigrid.c:       AD[E->ID[sl_minus][i].doff[3]] = AD[E->ID[sl_minus][i].doff[3]] * E->MASS[sl_minus][i] * amplifier;
Solver_multigrid.c:       AD[E->ID[sl_minus][i].doff[1]] = AD[E->ID[sl_minus][i].doff[1]] * E->MASS[sl_minus][i] * amplifier;
Solver_multigrid.c:       AD[E->ID[sl_minus][i].doff[2]] = AD[E->ID[sl_minus][i].doff[2]] * E->MASS[sl_minus][i] * amplifier;
Solver_multigrid.c:    const int dims = E->mesh.nsd;
Solver_multigrid.c:    if(start_lev == E->mesh.levmin)   {
Solver_multigrid.c:	fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Solver_multigrid.c:    for(el=1;el<=E->mesh.NEL[sl_minus];el++)
Solver_multigrid.c:	    node_coarse = E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:	    node_fine=E->IEN[start_lev][E->EL[sl_minus][el].sub[i]].node[i];
Solver_multigrid.c:	    eqn_coarse = E->ID[sl_minus][node_coarse].doff[1];
Solver_multigrid.c:	    eqn = E->ID[start_lev][node_fine].doff[1];
Solver_multigrid.c:	    eqn_coarse = E->ID[sl_minus][node_coarse].doff[2];
Solver_multigrid.c:	    eqn = E->ID[start_lev][node_fine].doff[2];
Solver_multigrid.c:		eqn_coarse = E->ID[sl_minus][node_coarse].doff[3];
Solver_multigrid.c:		eqn = E->ID[start_lev][node_fine].doff[3];
Solver_multigrid.c:    const int dims = E->mesh.nsd;
Solver_multigrid.c:    const int neq = E->mesh.NEQ[sl_plus];
Solver_multigrid.c:    const int nels = E->mesh.NEL[start_lev];
Solver_multigrid.c:    assert(start_lev != E->mesh.levmax  /* un_injection */);
Solver_multigrid.c:		node = E->IEN[start_lev][el].node[i];
Solver_multigrid.c:		node_plus=E->IEN[sl_plus][E->EL[start_lev][el].sub[i]].node[i];
Solver_multigrid.c:		eqn1 = E->ID[start_lev][node].doff[1];
Solver_multigrid.c:		eqn2 = E->ID[start_lev][node].doff[2];
Solver_multigrid.c:		eqn3 = E->ID[start_lev][node].doff[3];
Solver_multigrid.c:		eqn_plus1 = E->ID[sl_plus][node_plus].doff[1];
Solver_multigrid.c:		eqn_plus2 = E->ID[sl_plus][node_plus].doff[2];
Solver_multigrid.c:		eqn_plus3 = E->ID[sl_plus][node_plus].doff[3];
Solver_multigrid.c:		node = E->IEN[start_lev][el].node[i];
Solver_multigrid.c:		node_plus=E->IEN[sl_plus][E->EL[start_lev][el].sub[i]].node[i];
Solver_multigrid.c:		eqn1 = E->ID[start_lev][node].doff[1];
Solver_multigrid.c:		eqn2 = E->ID[start_lev][node].doff[2];
Solver_multigrid.c:		eqn_plus1 = E->ID[sl_plus][node_plus].doff[1];
Solver_multigrid.c:		eqn_plus2 = E->ID[sl_plus][node_plus].doff[2];
Solver_multigrid.c:    const int dims = E->mesh.nsd;
Solver_multigrid.c:    if(start_lev == E->mesh.levmin)   {
Solver_multigrid.c:        fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Solver_multigrid.c:      for(el=1;el<=E->mesh.NEL[sl_minus];el++)   {
Solver_multigrid.c:          node_coarse = E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:          node_fine=E->IEN[start_lev][E->EL[sl_minus][el].sub[i]].node[i];
Solver_multigrid.c:    const int elx=E->mesh.ELX[sl_minus];
Solver_multigrid.c:    const int elz=E->mesh.ELZ[sl_minus];
Solver_multigrid.c:    const int ely=E->mesh.ELY[sl_minus];
Solver_multigrid.c:    const int dims=E->mesh.nsd;
Solver_multigrid.c:    assert(start_lev != E->mesh.levmin );
Solver_multigrid.c:			node_minus = E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:			node = E->IEN[start_lev][E->EL[sl_minus][el].sub[i]].node[i];
Solver_multigrid.c:			if(E->mesh.periodic_x && elx==ex && 0==loc[i].plus[0]) {
Solver_multigrid.c:			    node_minus += (E->mesh.NOX[sl_minus]-1)*E->mesh.NOZ[sl_minus];
Solver_multigrid.c:			    node += (E->mesh.NOX[start_lev]-1)*E->mesh.NOZ[start_lev];
Solver_multigrid.c:    const int dims =E->mesh.nsd;
Solver_multigrid.c:    const int nox = E->mesh.NOX[level];
Solver_multigrid.c:    const int noz = E->mesh.NOZ[level];
Solver_multigrid.c:    const int noy = E->mesh.NOY[level];
Solver_multigrid.c:    const int high_eqn = E->mesh.NEQ[level];
Solver_multigrid.c:    if (start_lev==E->mesh.levmax) return;
Solver_multigrid.c:  	      x1=E->Interp[level][1][node1];
Solver_multigrid.c:	      x2=E->Interp[level][1][node2];
Solver_multigrid.c:	      eqn0=E->ID[level][node0].doff[1];
Solver_multigrid.c:	      eqn1=E->ID[level][node1].doff[1];
Solver_multigrid.c:	      eqn2=E->ID[level][node2].doff[1]; 
Solver_multigrid.c:	      eqn0=E->ID[level][node0].doff[2];
Solver_multigrid.c:	      eqn1=E->ID[level][node1].doff[2];
Solver_multigrid.c:	      eqn2=E->ID[level][node2].doff[2];
Solver_multigrid.c:		  eqn0=E->ID[level][node0].doff[3];
Solver_multigrid.c:		  eqn1=E->ID[level][node1].doff[3];
Solver_multigrid.c:		  eqn2=E->ID[level][node2].doff[3];	       
Solver_multigrid.c:  	        x1=E->Interp[level][2][node1];
Solver_multigrid.c:	        x2=E->Interp[level][2][node2];
Solver_multigrid.c:		eqn0=E->ID[level][node0].doff[1];
Solver_multigrid.c:		eqn1=E->ID[level][node1].doff[1];
Solver_multigrid.c:		eqn2=E->ID[level][node2].doff[1];  
Solver_multigrid.c:		eqn0=E->ID[level][node0].doff[2];
Solver_multigrid.c:		eqn1=E->ID[level][node1].doff[2];
Solver_multigrid.c:		eqn2=E->ID[level][node2].doff[2];
Solver_multigrid.c:		    eqn0=E->ID[level][node0].doff[3];
Solver_multigrid.c:		    eqn1=E->ID[level][node1].doff[3];
Solver_multigrid.c:		    eqn2=E->ID[level][node2].doff[3];	       
Solver_multigrid.c:	            x1=E->Interp[level][3][node1];
Solver_multigrid.c:	            x2=E->Interp[level][3][node2];
Solver_multigrid.c:		    eqn0=E->ID[level][node0].doff[1];
Solver_multigrid.c:		    eqn1=E->ID[level][node1].doff[1];
Solver_multigrid.c:		    eqn2=E->ID[level][node2].doff[1];  
Solver_multigrid.c:		    eqn0=E->ID[level][node0].doff[2];
Solver_multigrid.c:		    eqn1=E->ID[level][node1].doff[2];
Solver_multigrid.c:		    eqn2=E->ID[level][node2].doff[2];
Solver_multigrid.c:		    eqn0=E->ID[level][node0].doff[3];
Solver_multigrid.c:		    eqn1=E->ID[level][node1].doff[3];
Solver_multigrid.c:		    eqn2=E->ID[level][node2].doff[3];	       
Solver_multigrid.c:    const int nsd=E->mesh.nsd;
Solver_multigrid.c:    viscU=(float *)malloc((1+vpts*E->mesh.NEL[E->mesh.levmax  ])*sizeof(float));
Solver_multigrid.c:    viscD=(float *)malloc((1+vpts*E->mesh.NEL[E->mesh.levmax-1])*sizeof(float));
Solver_multigrid.c:    visc_from_gint_to_nodes(E,E->EVI[E->mesh.levmax],viscU,E->mesh.levmax);
Solver_multigrid.c:    visc_from_nodes_to_gint(E,viscU,E->EVI[E->mesh.levmax],E->mesh.levmax);
Solver_multigrid.c:  for(lv=E->mesh.levmax;lv>E->mesh.levmin;lv--){
Solver_multigrid.c:    if (E->viscosity.smooth_cycles==0)  {
Solver_multigrid.c:      visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:      visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:    else if (E->viscosity.smooth_cycles==1)  {
Solver_multigrid.c:      visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:      visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:    else if (E->viscosity.smooth_cycles==2)   {
Solver_multigrid.c:      visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:      inject_scalar_e(E,lv,viscU,E->EVI[sl_minus]);
Solver_multigrid.c:    else if (E->viscosity.smooth_cycles==3)   {
Solver_multigrid.c:      visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:      visc_from_ele_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:    visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:    const int dims =E->mesh.nsd;
Solver_multigrid.c:    const int nox = E->mesh.NOX[lev];
Solver_multigrid.c:    const int noz = E->mesh.NOZ[lev];
Solver_multigrid.c:    const int noy = E->mesh.NOY[lev];
Solver_multigrid.c:           x1=E->ECO[lev][E->NEI[lev].element[ends*(node1-1)]].size[1];
Solver_multigrid.c:           x2=E->ECO[lev][E->NEI[lev].element[(node2-1)*ends]].size[1];
Solver_multigrid.c:           E->Interp[lev][1][node1] = x1;
Solver_multigrid.c:           E->Interp[lev][1][node2] = x2;
Solver_multigrid.c:           x1=E->ECO[lev][E->NEI[lev].element[ends*(node1-1)]].size[2];
Solver_multigrid.c:           x2=E->ECO[lev][E->NEI[lev].element[(node2-1)*ends]].size[2];
Solver_multigrid.c:           E->Interp[lev][2][node1] = x1;
Solver_multigrid.c:           E->Interp[lev][2][node2] = x2;
Solver_multigrid.c:                    x1=E->ECO[lev][E->NEI[lev].element[ends*(node1-1)]].size[3];
Solver_multigrid.c:                    x2=E->ECO[lev][E->NEI[lev].element[(node2-1)*ends]].size[3];
Solver_multigrid.c:                    E->Interp[lev][3][node1] = x1;
Solver_multigrid.c:                    E->Interp[lev][3][node2] = x2;
Solver_multigrid.c:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:    const int dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:    const int vpts=vpoints[E->mesh.nsd];
Solver_multigrid.c:            e = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:    const int nno_minus=E->mesh.NNO[start_lev-1];
Solver_multigrid.c:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:                node1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:                    node=E->IEN[start_lev][node1].node[j];
Solver_multigrid.c:                node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:                AD[node] += w * E->TWW[sl_minus][el].node[i];
Solver_multigrid.c:       AD[i] *= E->MASS[sl_minus][i];
Solver_multigrid.c:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:    const int vpts=vpoints[E->mesh.nsd];
Solver_multigrid.c:                e = E->EL[sl_minus][el].sub[i];
Stokes_flow_Incomp.c:    const int npno = E->mesh.npno;
Stokes_flow_Incomp.c:    const int gnpno = E->mesh.npno;
Stokes_flow_Incomp.c:    const int nno = E->mesh.nno;
Stokes_flow_Incomp.c:    const int dims = E->mesh.nsd;
Stokes_flow_Incomp.c:    const int neq = E->mesh.neq;
Stokes_flow_Incomp.c:    const int gneq = E->mesh.neq;
Stokes_flow_Incomp.c:    cycles=E->control.p_iterations;
Stokes_flow_Incomp.c:    residual_ddash=solve_Ahat_p_fhat(E,E->U,E->P,E->F,E->control.accuracy,&cycles);
Stokes_flow_Incomp.c:    v_from_vector(E,E->V,E->U); 
Stokes_flow_Incomp.c:    dp_to_nodes(E,E->P,E->NP,E->mesh.levmax);   
Stokes_flow_Incomp.c:  const int dims=E->mesh.nsd;
Stokes_flow_Incomp.c:  const int n=loc_mat_size[E->mesh.nsd];
Stokes_flow_Incomp.c:  npno=E->mesh.npno;
Stokes_flow_Incomp.c:  neq=E->mesh.neq;
Stokes_flow_Incomp.c:  gnpno=E->mesh.npno;
Stokes_flow_Incomp.c:  gneq=E->mesh.neq;
Stokes_flow_Incomp.c:  lev=E->mesh.levmax;
Stokes_flow_Incomp.c:  valid=solve_del2_u(E,u1,Ah,imp*v_res,E->mesh.levmax);
Stokes_flow_Incomp.c:  E->monitor.vdotv = sqrt(vdot(E,V,V,lev)/gneq);
Stokes_flow_Incomp.c:  E->monitor.incompressibility = residual/E->monitor.vdotv;
Stokes_flow_Incomp.c:   if (E->control.print_convergence)  {
Stokes_flow_Incomp.c:         fprintf(E->fp,"AhatP (%03d) after %g seconds with div/v=%.3e for step %d\n",count,CPU_time0()-time0,E->monitor.incompressibility,E->monitor.solution_cycles); /**/
Stokes_flow_Incomp.c:         fflush(E->fp);
Stokes_flow_Incomp.c:/*   while( count==0 || ((count < *steps_max) && (dvelocity >= imp || dpressure >=imp) && E->monitor.incompressibility >= E->control.tole_comp) )  { */
Stokes_flow_Incomp.c:       z1[j] = E->BPI[lev][j]*r1[j];
Stokes_flow_Incomp.c:     E->monitor.vdotv = vdot(E,V,V,E->mesh.levmax);
Stokes_flow_Incomp.c:     E->monitor.incompressibility = sqrt((gneq/gnpno)*(1.0e-32+pdot(E,Ah,Ah,lev)/(1.0e-32+E->monitor.vdotv)));
Stokes_flow_Incomp.c:     dvelocity=alpha*sqrt(vdot(E,u1,u1,lev)/(1.0e-32+E->monitor.vdotv));
Stokes_flow_Incomp.c:     if (E->control.print_convergence )  {
Stokes_flow_Incomp.c:       fprintf(E->fp,"AhatP (%03d) after %g seconds with div/v=%.3e for step %d dv=%g dp=%g\n",count,CPU_time0()-time0,E->monitor.incompressibility,E->monitor.solution_cycles,dvelocity,dpressure); /**/
Stokes_flow_Incomp.c:       fflush(E->fp);
Stokes_flow_Incomp.c:      fprintf(E->fp,"Convergence of velocity solver may affect continuity\n");
Stokes_flow_Incomp.c:      fprintf(E->fp,"Consider running with the `see_convergence=on' option\n");
Stokes_flow_Incomp.c:      fprintf(E->fp,"To evaluate the performance of the current relaxation parameters\n");
Stokes_flow_Incomp.c:      fflush(E->fp);
Stokes_flow_Incomp.c:  const int addi_dof = additional_dof[E->mesh.nsd];
Stokes_flow_Incomp.c:  const int nno = E->mesh.nno;
Stokes_flow_Incomp.c:  const int dofs = E->mesh.dof;
Stokes_flow_Incomp.c:      if(E->node[node] & OFFSIDE) continue;
Stokes_flow_Incomp.c:      V[1][node] = F[E->id[node].doff[1]]; 
Stokes_flow_Incomp.c:      V[2][node] = F[E->id[node].doff[2]]; 
Stokes_flow_Incomp.c:      if(dofs==3) V[3][node] = F[E->id[node].doff[3]];
Stokes_flow_Incomp.c:      if (E->node[node] & VBX)
Stokes_flow_Incomp.c:             V[1][node] = E->VB[1][node]; 
Stokes_flow_Incomp.c:      if (E->node[node] & VBZ)
Stokes_flow_Incomp.c:             V[2][node] = E->VB[2][node]; 
Stokes_flow_Incomp.c:      if (dofs==3 && E->node[node] & VBY)
Stokes_flow_Incomp.c:             V[3][node] = E->VB[3][node]; 
Topo_gravity.c:    const int dims=E->mesh.nsd;
Topo_gravity.c:    const int noz=E->mesh.noz;
Topo_gravity.c:    const int noy=E->mesh.noy;
Topo_gravity.c:    const int nno=E->mesh.nno;
Topo_gravity.c:    const int elz = E->mesh.elz;
Topo_gravity.c:    const int ely = E->mesh.ely;
Topo_gravity.c:    const int lev=E->mesh.levmax;
Topo_gravity.c:    lnsf=E->mesh.nsf;
Topo_gravity.c:    for(els=1;els<=E->mesh.snel;els++) {
Topo_gravity.c:	    el = E->surf_element[els];
Topo_gravity.c:          nodeb= E->ien[elb].node[m+1];
Topo_gravity.c:          eub[m*dims  ] = E->V[1][nodeb];
Topo_gravity.c:          eub[m*dims+1] = E->V[2][nodeb];
Topo_gravity.c:            eub[m*dims+2] = E->V[3][nodeb]; 
Topo_gravity.c:          node = E->ien[el].node[m+1];
Topo_gravity.c:          eu [m*dims  ] = E->V[1][node];
Topo_gravity.c:          eu [m*dims+1] = E->V[2][node];
Topo_gravity.c:            eu [m*dims+2] = E->V[3][node];
Topo_gravity.c:          res[m]  = eltf[m]  - E->elt_del[lev][el].g[m][0]  * E->P[el];
Topo_gravity.c:          resb[m] = eltfb[m] - E->elt_del[lev][elb].g[m][0]* E->P[elb];
Topo_gravity.c:		    RL[E->sien[els].node[1]] += resb[(m-1)*dims+1];  
Topo_gravity.c:		    RL[E->sien[els].node[2]] += resb[(m-1)*dims+1];  
Topo_gravity.c:		    RL[E->sien[els].node[3]] += resb[(m-1)*dims+1];  
Topo_gravity.c:		    RL[E->sien[els].node[4]] += resb[(m-1)*dims+1];  
Topo_gravity.c:		    RU[E->sien[els].node[1]] += res[(m-1)*dims+1];  
Topo_gravity.c:		    RU[E->sien[els].node[2]] += res[(m-1)*dims+1];  
Topo_gravity.c:		    RU[E->sien[els].node[3]] += res[(m-1)*dims+1];  
Topo_gravity.c:		    RU[E->sien[els].node[4]] += res[(m-1)*dims+1];  
Topo_gravity.c:    for(els=1;els<=E->mesh.snel;els++) {
Topo_gravity.c:	    el = E->surf_element[els];
Topo_gravity.c:			 * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Topo_gravity.c:			 * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Topo_gravity.c:	      SL[E->sien[els].node[m]] += eltTL[m-1];
Topo_gravity.c:	           SU[E->sien[els].node[m]] += eltTU[m-1];
Topo_gravity.c:      for(i=1;i<=E->mesh.nsf;i++)
Topo_gravity.c:      for(i=1;i<=E->mesh.nsf;i++)
Topo_gravity.c:    Szz=(float *) malloc((1+E->mesh.nno)*sizeof(float));
Topo_gravity.c:    get_Szz(E,E->P,Szz,ii);
Topo_gravity.c:    for(snode=1;snode<=E->mesh.nsf;snode++)   {
Topo_gravity.c:           node = E->surf_node[snode];
Topo_gravity.c:	   tpgb[snode] = 2*Szz[node-E->mesh.noz+1]-Szz[node-E->mesh.noz+2]; 
Topo_gravity.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Topo_gravity.c:    const int nno=E->mesh.nno;
Topo_gravity.c:    const int lev=E->mesh.levmax;
Topo_gravity.c:    SXX = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Topo_gravity.c:    SYY = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Topo_gravity.c:    SXY = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Topo_gravity.c:    SXZ = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Topo_gravity.c:    SZY = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Topo_gravity.c:    for(i=1;i<=E->mesh.nno;i++) {
Topo_gravity.c:    for(e=1;e<=E->mesh.nel;e++)  {
Topo_gravity.c:      get_global_shape_fn(E,e,&GN,&GNx,&dOmega,0,E->mesh.levmax);
Topo_gravity.c:	  visc[i] =  E->EVI[E->mesh.levmax][(e-1)*vpts+i] * dOmega.vpt[i];
Topo_gravity.c:          VZ[j] = E->V[2][E->ien[e].node[j]];
Topo_gravity.c:      Szz /= E->eco[e].area;
Topo_gravity.c:	    node = E->ien[e].node[j];
Topo_gravity.c:	    SZZ[node] += E->TWW[E->mesh.levmax][e].node[j] * Szz;  
Topo_gravity.c:   for(node=1;node<=E->mesh.nno;node++)  {
Topo_gravity.c:     SZZ[node] = SZZ[node]*E->Mass[node];
Viscosity_structures.c:    E->viscosity.update_allowed = 0; 
Viscosity_structures.c:    E->viscosity.SDEPV = E->viscosity.TDEPV = E->viscosity.CHEMDEPV = 0;
Viscosity_structures.c:    E->viscosity.EXPX=0;
Viscosity_structures.c:    input_string("Viscosity",E->viscosity.STRUCTURE,NULL);   /* Which form of viscosity */
Viscosity_structures.c:    input_boolean("VISC_EQUIVDD",&(E->viscosity.EQUIVDD),"off");    /* Whether to average it */
Viscosity_structures.c:    input_int("equivdd_opt",&(E->viscosity.equivddopt),"1");
Viscosity_structures.c:    input_int("equivdd_x",&(E->viscosity.proflocx),"1");
Viscosity_structures.c:    input_int("equivdd_y",&(E->viscosity.proflocy),"1");
Viscosity_structures.c:    input_boolean("VISC_SMOOTH",&(E->viscosity.SMOOTH),"off");
Viscosity_structures.c:    input_int ("visc_smooth_cycles",&(E->viscosity.smooth_cycles),"0");
Viscosity_structures.c:    if ( strcmp(E->viscosity.STRUCTURE,"system") == 0) /* Interpret */ {
Viscosity_structures.c:      fprintf(E->fp,"Viscosity derived from system state\n");
Viscosity_structures.c:      E->viscosity.FROM_SYSTEM = 1;
Viscosity_structures.c:       E->viscosity.N0[i]=1.0;
Viscosity_structures.c:       E->viscosity.T[i] = 0.0;
Viscosity_structures.c:       E->viscosity.Z[i] = 0.0;
Viscosity_structures.c:       E->viscosity.E[i] = 0.0;
Viscosity_structures.c:       E->viscosity.T0[i] = 0.0;
Viscosity_structures.c:    input_int("rheol",&(E->viscosity.RHEOL),"essential");
Viscosity_structures.c:    input_int("num_mat",&(E->viscosity.num_mat),"1");
Viscosity_structures.c:    input_float_vector("viscT",E->viscosity.num_mat,(E->viscosity.T));  /* redundant */
Viscosity_structures.c:    input_float_vector("viscT1",E->viscosity.num_mat,(E->viscosity.T));
Viscosity_structures.c:    input_float_vector("viscZ",E->viscosity.num_mat,(E->viscosity.Z));
Viscosity_structures.c:    input_float_vector("viscE",E->viscosity.num_mat,(E->viscosity.E));
Viscosity_structures.c:    input_float_vector("viscT0",E->viscosity.num_mat,(E->viscosity.T0));
Viscosity_structures.c:    input_float_vector("visc0",E->viscosity.num_mat,(E->viscosity.N0)); /* redundant */
Viscosity_structures.c:    input_float_vector("viscN0",E->viscosity.num_mat,(E->viscosity.N0));
Viscosity_structures.c:    input_boolean("CHEMDEPV",&(E->viscosity.CHEMDEPV),"on");
Viscosity_structures.c:    input_boolean("TDEPV",&(E->viscosity.TDEPV),"on");
Viscosity_structures.c:    input_boolean("SDEPV",&(E->viscosity.SDEPV),"off");
Viscosity_structures.c:    input_float("sdepv_misfit",&(E->viscosity.sdepv_misfit),"0.001");
Viscosity_structures.c:    input_float_vector("sdepv_expt",E->viscosity.num_mat,(E->viscosity.sdepv_expt));
Viscosity_structures.c:    input_float_vector("sdepv_trns",E->viscosity.num_mat,(E->viscosity.sdepv_trns));
Viscosity_structures.c:    input_boolean("TDEPV_AVE",&(E->viscosity.TDEPV_AVE),"off");
Viscosity_structures.c:    input_boolean("VFREEZE",&(E->viscosity.FREEZE),"off");
Viscosity_structures.c:    input_boolean("VMAX",&(E->viscosity.MAX),"off");
Viscosity_structures.c:    input_boolean("VMIN",&(E->viscosity.MIN),"off");
Viscosity_structures.c:    input_boolean("VISC_UPDATE",&(E->viscosity.update_allowed),"on");
Viscosity_structures.c:    input_float("freeze_thresh",&(E->viscosity.freeze_thresh),"0.0");
Viscosity_structures.c:    input_float("freeze_value",&(E->viscosity.freeze_value),"1.0");
Viscosity_structures.c:    input_float("visc_max",&(E->viscosity.max_value),"nodefault");
Viscosity_structures.c:    input_float("visc_min",&(E->viscosity.min_value),"nodefault");
Viscosity_structures.c:    input_boolean("VISC_GUESS",&(E->viscosity.guess),"off");
Viscosity_structures.c:    input_string("visc_old_file",E->viscosity.old_file," ");
Viscosity_structures.c:    for (l=0;l<E->viscosity.num_mat;l++)  {
Viscosity_structures.c:      E->viscosity.Z[l] = E->data.density*E->data.grav_acc*E->data.layer_meter*E->viscosity.Z[l]/(E->data.gas_const*E->data.ref_temperature);
Viscosity_structures.c:      E->viscosity.E[l] = E->viscosity.E[l]/(E->data.gas_const*E->data.ref_temperature);
Viscosity_structures.c:     fprintf(E->fp,"E & Z %g %g\n",E->viscosity.E[l],E->viscosity.Z[l]);
Viscosity_structures.c:    if(!E->viscosity.update_allowed)  {
Viscosity_structures.c:      get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    if(E->viscosity.TDEPV)
Viscosity_structures.c:    if(E->viscosity.SDEPV)
Viscosity_structures.c:/*    if (E->viscosity.SMOOTH) 
Viscosity_structures.c:    if(E->viscosity.MAX) {
Viscosity_structures.c:      for(i=1;i<=E->mesh.nel;i++)
Viscosity_structures.c:            if(evisc[(i-1)*vpts + j] > E->viscosity.max_value)
Viscosity_structures.c:               evisc[(i-1)*vpts + j] = E->viscosity.max_value;
Viscosity_structures.c:    if(E->viscosity.MIN) {
Viscosity_structures.c:      for(i=1;i<=E->mesh.nel;i++)
Viscosity_structures.c:            if(evisc[(i-1)*vpts + j] < E->viscosity.min_value)
Viscosity_structures.c:               evisc[(i-1)*vpts + j] = E->viscosity.min_value;
Viscosity_structures.c:    v_to_nodes(E,evisc,visc,E->mesh.levmax);
Viscosity_structures.c:    ViscCentre = (float *)malloc((E->mesh.nno+10)*sizeof(float));
Viscosity_structures.c:    for(i=1;i<=E->viscosity.smooth_cycles;i++)  {
Viscosity_structures.c:	p_to_centres(E,visc,ViscCentre,E->mesh.levmax);
Viscosity_structures.c:	p_to_nodes(E,ViscCentre,visc,E->mesh.levmax);
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:    for(i=1;i<=E->mesh.nel;i++)   {
Viscosity_structures.c:      for(jj=1;jj<=vpoints[E->mesh.nsd];jj++)  {
Viscosity_structures.c:        EEta[ (i-1)*vpoints[E->mesh.nsd]+jj ]=E->viscosity.N0[E->mat[i]-1];
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:    const int nel = E->mesh.nel;
Viscosity_structures.c:    switch (E->viscosity.RHEOL)   {
Viscosity_structures.c:            fprintf(E->fp,"\tRheological option 1:\n");
Viscosity_structures.c:            for(l=1;l<=E->viscosity.num_mat;l++) {
Viscosity_structures.c:              fprintf(E->fp,"\tlayer %d/%d: E=%g T1=%g \n",
Viscosity_structures.c:                      l,E->viscosity.num_mat,
Viscosity_structures.c:                      E->viscosity.E[l-1],E->viscosity.T[l-1]);
Viscosity_structures.c:            fflush(E->fp);
Viscosity_structures.c:        if(E->control.phasevisc) {
Viscosity_structures.c:            return_horiz_ave(E,E->T,E->Have.T);
Viscosity_structures.c:            l = E->mat[i];
Viscosity_structures.c:            tempa = E->viscosity.N0[l-1];
Viscosity_structures.c:               TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:                  temp0 += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:               if(E->control.visc_leftcor){
Viscosity_structures.c:                   if(E->X[1][E->ien[i].node[jj]]<=E->control.x_weakzone_leftcor && E->X[2][E->ien[i].node[jj]]>=E->control.y_weakzone_leftcor){
Viscosity_structures.c:                       visc_weakzone = E->control.visc_weakzone;
Viscosity_structures.c:               if(E->control.visc_rightcor){
Viscosity_structures.c:                   if(E->X[1][E->ien[i].node[jj]]>=E->control.x_weakzone_rightcor && E->X[2][E->ien[i].node[jj]]>=E->control.y_weakzone_rightcor){
Viscosity_structures.c:                       visc_weakzone = E->control.visc_weakzone;
Viscosity_structures.c:               if(E->control.visc_mid){
Viscosity_structures.c:                   if(E->X[1][E->ien[i].node[jj]]>=E->control.x_weakzone_mid_left && E->X[1][E->ien[i].node[jj]]<=E->control.x_weakzone_mid_right && E->X[2][E->ien[i].node[jj]]>=E->control.y_weakzone_mid){
Viscosity_structures.c:                       visc_weakzone = E->control.visc_weakzone;
Viscosity_structures.c:               if(E->control.visc_mid_dip){
Viscosity_structures.c:                   tempdist = (E->X[1][E->ien[i].node[jj]]-E->control.x_weakzone_mid_left)*tan(E->control.dip_weakzone_mid*3.14159265/180.0) + 1.0 - E->X[2][E->ien[i].node[jj]];   
Viscosity_structures.c:                   if(  tempdist >= 0.0 && tempdist <= (E->control.x_weakzone_mid_right-E->control.x_weakzone_mid_left)*tan(E->control.dip_weakzone_mid*3.14159265/180.0)  && E->X[2][E->ien[i].node[jj]]>=E->control.y_weakzone_mid){
Viscosity_structures.c:                       visc_weakzone = E->control.visc_weakzone;
Viscosity_structures.c:               if(E->control.visc_platebond){
Viscosity_structures.c:                   if(E->control.imposevelo){
Viscosity_structures.c:                       velobegin=E->VB[1][E->mesh.noz*7];
Viscosity_structures.c:                       while(newnum<=E->mesh.nox-1 && E->VB[1][E->mesh.noz*newnum]>velobegin-910.0){
Viscosity_structures.c:                       if(E->X[2][E->ien[i].node[jj]]>=E->control.y_weakzone_platebond && E->X[1][E->ien[i].node[jj]] - E->X[1][markvnum*E->mesh.noz] >= 0.0-E->control.width_weakzone_platebond && E->X[1][E->ien[i].node[jj]] - E->X[1][markvnum*E->mesh.noz] <= E->control.width_weakzone_platebond ){
Viscosity_structures.c:                           visc_weakzone = E->control.visc_weakzone;
Viscosity_structures.c:                   if (E->control.trechmigrate){
Viscosity_structures.c:                       loc_mid = E->control.velo_surf_loc_mid;
Viscosity_structures.c:                       loc_mid += E->control.velo_surf_loc_mid_rate*E->monitor.elapsed_time*E->control.timescale;
Viscosity_structures.c:                       t1=E->X[1][E->ien[i].node[jj]];
Viscosity_structures.c:                       r1=E->X[2][E->ien[i].node[jj]];
Viscosity_structures.c:                       tempdist = (t1-loc_mid)*tan(E->control.dip_margin*3.14159265/180.0) + 1.0-r1;
Viscosity_structures.c:                       if(tempdist>=(0.0-E->control.left_weakzone_platebond)*tan(E->control.dip_margin*3.14159265/180.0) && tempdist<=E->control.right_weakzone_platebond*tan(E->control.dip_margin*3.14159265/180.0) && r1>=E->control.y_weakzone_platebond){
Viscosity_structures.c:                           visc_weakzone = E->control.visc_weakzone;
Viscosity_structures.c:               if(E->control.slab_visc){
Viscosity_structures.c:                   if(E->X[2][E->ien[i].node[jj]]>=E->control.slab_visc_depth&&E->X[2][E->ien[i].node[jj]]<=E->viscosity.zlith){
Viscosity_structures.c:                       if(temp0<E->control.inter_temp-E->control.temp_slabvisc){
Viscosity_structures.c:                           viscincreaseslab=E->control.viscincreaseslab;
Viscosity_structures.c:               if(E->control.phasevisc) {
Viscosity_structures.c:                   if(E->X[2][E->ien[i].node[jj]]<E->viscosity.zlm+E->control.phaseTop&&E->X[2][E->ien[i].node[jj]]>E->viscosity.zlm-E->control.phaseBot) {
Viscosity_structures.c:                       newelz = ((i-1) % E->mesh.elz) + 1;
Viscosity_structures.c:                       nz = (E->ien[i].node[jj] % E->mesh.noz) +1;
Viscosity_structures.c:                       e_pressure = E->viscosity.zlm - E->X[2][E->ien[i].node[jj]] - E->control.clapeyron670*(temp0-E->control.transT670);
Viscosity_structures.c:                       Bvisc = pt5 * (one + tanh(E->control.width670 * e_pressure));
Viscosity_structures.c:                       /*printf("%f %f %f %f\n",E->X[2][E->ien[i].node[jj]],Bvisc,E->data.layer_meter/E->control.width670,e_pressure);*/
Viscosity_structures.c:                       if(Bvisc<E->control.phaseffactorLa&&Bvisc>E->control.phaseffactorSm){
Viscosity_structures.c:                           if(E->control.phasevisc_slab) {
Viscosity_structures.c:                               if(temp0<=E->Have.T[nz]+E->control.phasevisc_slab_T) {
Viscosity_structures.c:                                   viscreducephase=E->control.ViscReduce;
Viscosity_structures.c:                               viscreducephase=E->control.ViscReduce;
Viscosity_structures.c:                               /*printf("%f %f\n",E->viscosity.N0[l-1], E->viscosity.N0[l-1]*viscreducephase*visc_weakzone*viscincreaseslab*exp(E->viscosity.E[l-1]*(E->viscosity.T[l-1]-temp0)));*/
Viscosity_structures.c:               if(E->control.phasevisc_C) {
Viscosity_structures.c:                   if(E->X[2][E->ien[i].node[jj]]<E->viscosity.zlm+E->control.phaseTop&&E->X[2][E->ien[i].node[jj]]>E->viscosity.zlm-E->control.phaseBot) {
Viscosity_structures.c:                       viscreducephase=E->control.ViscReduce;                       
Viscosity_structures.c:               temp2 = E->viscosity.E[l-1]*(E->viscosity.T[l-1]-temp0);
Viscosity_structures.c:               tempa = E->viscosity.N0[l-1];
Viscosity_structures.c:               if(E->control.visc_const_cor){
Viscosity_structures.c:                   if(E->control.visc_leftcor){
Viscosity_structures.c:                       if(E->X[1][E->ien[i].node[jj]]<=E->control.x_weakzone_leftcor && E->X[2][E->ien[i].node[jj]]>=E->control.y_weakzone_leftcor){
Viscosity_structures.c:                           EEta[(i-1)*vpts + jj] = E->control.visc_weakzone;
Viscosity_structures.c:                   if(E->control.visc_rightcor){
Viscosity_structures.c:                       if(E->X[1][E->ien[i].node[jj]]>=E->control.x_weakzone_rightcor && E->X[2][E->ien[i].node[jj]]>=E->control.y_weakzone_rightcor){
Viscosity_structures.c:                           EEta[(i-1)*vpts + jj] = E->control.visc_weakzone;
Viscosity_structures.c:                   if(E->control.visc_mid){
Viscosity_structures.c:                       if(E->X[1][E->ien[i].node[jj]]>=E->control.x_weakzone_mid_left && E->X[1][E->ien[i].node[jj]]<=E->control.x_weakzone_mid_right && E->X[2][E->ien[i].node[jj]]>=E->control.y_weakzone_mid){
Viscosity_structures.c:                           EEta[(i-1)*vpts + jj] = E->control.visc_weakzone;
Viscosity_structures.c:                   if(E->control.visc_mid_dip){
Viscosity_structures.c:                       tempdist = (E->X[1][E->ien[i].node[jj]]-E->control.x_weakzone_mid_left)*tan(E->control.dip_weakzone_mid*3.14159265/180.0) + 1.0 - E->X[2][E->ien[i].node[jj]];   
Viscosity_structures.c:                       if(  tempdist >= 0.0 && tempdist <= (E->control.x_weakzone_mid_right-E->control.x_weakzone_mid_left)*tan(E->control.dip_weakzone_mid*3.14159265/180.0)  && E->X[2][E->ien[i].node[jj]]>=E->control.y_weakzone_mid){
Viscosity_structures.c:                           EEta[(i-1)*vpts + jj]  = E->control.visc_weakzone;
Viscosity_structures.c:                   if(E->control.visc_platebond){
Viscosity_structures.c:                       if(E->control.imposevelo){
Viscosity_structures.c:                           velobegin=E->VB[1][E->mesh.noz*7];
Viscosity_structures.c:                           while(newnum<=E->mesh.nox-1 && E->VB[1][E->mesh.noz*newnum]>velobegin-910.0){
Viscosity_structures.c:                           if(E->X[2][E->ien[i].node[jj]]>=E->control.y_weakzone_platebond && E->X[1][E->ien[i].node[jj]] - E->X[1][markvnum*E->mesh.noz] >= 0.0-E->control.width_weakzone_platebond && E->X[1][E->ien[i].node[jj]] - E->X[1][markvnum*E->mesh.noz] <= E->control.width_weakzone_platebond ){
Viscosity_structures.c:                               EEta[(i-1)*vpts + jj]  = E->control.visc_weakzone;
Viscosity_structures.c:                       if (E->control.trechmigrate){
Viscosity_structures.c:                           loc_mid = E->control.velo_surf_loc_mid;
Viscosity_structures.c:                           loc_mid += E->control.velo_surf_loc_mid_rate*E->monitor.elapsed_time*E->control.timescale;
Viscosity_structures.c:                           t1=E->X[1][E->ien[i].node[jj]];
Viscosity_structures.c:                           r1=E->X[2][E->ien[i].node[jj]];
Viscosity_structures.c:                           tempdist = (t1-loc_mid)*tan(E->control.dip_margin*3.14159265/180.0) + 1.0-r1;
Viscosity_structures.c:                           if(tempdist>=(0.0-E->control.left_weakzone_platebond)*tan(E->control.dip_margin*3.14159265/180.0) && tempdist<=E->control.right_weakzone_platebond*tan(E->control.dip_margin*3.14159265/180.0) && r1>=E->control.y_weakzone_platebond){
Viscosity_structures.c:                               EEta[(i-1)*vpts + jj] = E->control.visc_weakzone;
Viscosity_structures.c:            fprintf(E->fp,"\tRheological option 3:\n");
Viscosity_structures.c:            for(l=1;l<=E->viscosity.num_mat;l++) {
Viscosity_structures.c:              fprintf(E->fp,"\tlayer %d/%d: E=%g T1=%g \n",
Viscosity_structures.c:                      l,E->viscosity.num_mat,
Viscosity_structures.c:                      E->viscosity.E[l-1],E->viscosity.T[l-1]);
Viscosity_structures.c:            fflush(E->fp);
Viscosity_structures.c:            l = E->mat[i];
Viscosity_structures.c:            tempa = E->viscosity.N0[l-1];
Viscosity_structures.c:               TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:                  rii[jj] += E->X[2][E->ien[i].node[kk]]*E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:                  temp[jj] += E->T[E->ien[i].node[kk]]*E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:               temp1 = (E->viscosity.E[E->mat[i]-1]+ 
Viscosity_structures.c:                   E->viscosity.Z[E->mat[i]-1]*(1.0-rii[jj]))
Viscosity_structures.c:                          /(temp[jj]+E->control.Ts)
Viscosity_structures.c:                 -(E->viscosity.E[E->mat[i]-1]+
Viscosity_structures.c:                   E->viscosity.Z[E->mat[i]-1])
Viscosity_structures.c:                          /(1.0+E->control.Ts);
Viscosity_structures.c:               EEta[ (i-1)*vpoints[E->mesh.nsd]+jj ]=E->viscosity.N0[E->mat[i]-1]*exp(temp1);
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    const int nel = E->mesh.nel;
Viscosity_structures.c:        exponent1= one-one/E->viscosity.sdepv_expt[E->mat[e]-1];
Viscosity_structures.c:	    scale=pow(two*eedot[e]/E->viscosity.sdepv_trns[E->mat[e]-1],exponent1);
Viscosity_structures.c:    const int dims = E->mesh.nsd;
Viscosity_structures.c:    const int lev = E->mesh.levmax;
Viscosity_structures.c:    const int nno = E->mesh.nno;
Viscosity_structures.c:    nel = E->mesh.nel;
Viscosity_structures.c:        n=E->ien[e].node[i];
Viscosity_structures.c:          VV[1][i] = E->V[1][n];
Viscosity_structures.c:          VV[2][i] = E->V[2][n];
Viscosity_structures.c:          if(dims==3) VV[3][i] = E->V[3][n];
Viscosity_structures.c:    const int dims = E->mesh.nsd;
Viscosity_structures.c:    const int lev = E->mesh.levmax;
Viscosity_structures.c:    const int nno = E->mesh.nno;
Viscosity_structures.c:    nel = E->mesh.nel;
Viscosity_structures.c:        n=E->ien[e].node[i];
Viscosity_structures.c:          VV[1][i] = E->V[1][n];
Viscosity_structures.c:          VV[2][i] = E->V[2][n];
Viscosity_structures.c:          if(dims==3) VV[3][i] = E->V[3][n];
Viscosity_structures.c:    if (x2>=E->viscosity.zlith){
Viscosity_structures.c:    else if(x2>=E->viscosity.z300){
Viscosity_structures.c:    else if(x2>=E->viscosity.z410){
Viscosity_structures.c:    else if(x2>=E->viscosity.zlm){
Viscosity_structures.c:    else if(x2>=E->viscosity.z1000){
