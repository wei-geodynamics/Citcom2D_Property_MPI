/*****************************************
 *   CC  III  TTTTT   CC   OO   MM MM    *
 *  C     I     T    C    O  O  M M M    *
 *  C     I     T    C    O  O  M   M    *
 *   CC  III    T     CC   OO   M   M    *
 *                                       *  
 * Developed at CIT for COnvection in    *
 * the Mantle by Louis Moresi 1992-today *
 *                                       *
 * You are free to use this code but it  * 
 * is distrubuted as BeWare i.e. it does *
 * not carry any guarantees or warranties *
 * of reliability.                       *
 *                                       *
 * Please respect all the time and work  *
 * that went into the development of the *
 * code.                                 *  
 *                                       *
 * LM                                    *
 *****************************************/
#include <math.h>
#include <malloc.h>
#include <sys/types.h>
#include "element_definitions.h"
#include "global_defs.h"

void general_stokes_solver(E) struct All_variables *E;

{
  void construct_stiffness_B_matrix();
  void velocities_conform_bcs();
  void assemble_forces();
  double fvdot();
  double vnorm_nonnewt();
  void get_system_viscosity();

  double vmag;
  double Udot_mag, dUdot_mag;
  double CPU_time0(), time;
  int count, i, j, k;

  static double *oldU, *delta_U;
  static int visits = 0;

  const int nno = E->lmesh.nno;
  const int nel = E->lmesh.nel;
  const int nnov = E->lmesh.nnov;
  const int neq = E->lmesh.neq;
  const int vpts = vpoints[E->mesh.nsd];
  const int dims = E->mesh.nsd;
  const int addi_dof = additional_dof[dims];

  if (visits == 0)
  {
    oldU = (double *)malloc((neq + 2) * sizeof(double));
    delta_U = (double *)malloc((neq + 2) * sizeof(double));
    for (i = 0; i <= neq; i++)
      oldU[i] = 0.0;
  }
  visits++;
  /* FIRST store the old velocity field */

  E->monitor.elapsed_time_vsoln1 = E->monitor.elapsed_time_vsoln;
  E->monitor.elapsed_time_vsoln = E->monitor.elapsed_time;

  if (E->parallel.me == 0)
    time = CPU_time0();

  velocities_conform_bcs(E, E->U);

  assemble_forces(E, 0);

  count = 1;

  /* Solve Stokes 1st time a little more accurate */
  if (visits == 1)
  {
    E->viscosity.sdepv_misfit *= 0.2;
    E->control.accuracy *= 0.2;
  }
  else if (visits == 2)
  {
    E->viscosity.sdepv_misfit *= 5;
    E->control.accuracy *= 5;
  }

  do
  {

    if (E->viscosity.update_allowed)
      get_system_viscosity(E, 1, E->EVI[E->mesh.levmax], E->VI[E->mesh.levmax]);

    construct_stiffness_B_matrix(E);

    solve_constrained_flow_iterative(E);

    Udot_mag = sqrt(global_vdot(E, E->U, E->U, E->mesh.levmax));
    fprintf(E->fp, "%lf %.6e \n", E->monitor.elapsed_time, Udot_mag);
    fflush(E->fp);

    fprintf(stderr, "kinetic energy= %.7e at time= %lf for step %d\n", Udot_mag, E->monitor.elapsed_time, E->monitor.solution_cycles);

    if (E->viscosity.SDEPV)
    {
      for (i = 0; i < neq; i++)
      {
        delta_U[i] = E->U[i] - oldU[i];
        oldU[i] = E->U[i];
      }
      Udot_mag = sqrt(fvdot(E, oldU, oldU, E->mesh.levmax));
      dUdot_mag = sqrt(global_vdot(E, delta_U, delta_U, E->mesh.levmax));
      if (E->parallel.me == 0)
      {
        fprintf(stderr, "Stress dependent viscosity: DUdot = %.4e (%.4e) for iteration %d\n", dUdot_mag, Udot_mag, count);
        fprintf(E->fp, "Stress dependent viscosity: DUdot = %.4e (%.4e) for iteration %d\n", dUdot_mag, Udot_mag, count);
        fflush(E->fp);
      }

      count++;
    } /* end for SDEPV   */

  } while ((count < 50) && (dUdot_mag > E->viscosity.sdepv_misfit) && E->viscosity.SDEPV);

  fflush(E->fp);

  return;
}
